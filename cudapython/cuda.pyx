# Copyright 2021 NVIDIA Corporation.  All rights reserved.
#
# Please refer to the NVIDIA end user license agreement (EULA) associated
# with this source code for terms and conditions that govern your use of
# this software. Any use, reproduction, disclosure, or distribution of
# this software and related documentation outside the terms of the EULA
# is strictly prohibited.
from typing import List, Tuple, Any
from enum import Enum
import cython
import ctypes
from libc.stdlib cimport calloc, free
from libc.string cimport memcpy
from libc.stdint cimport int32_t, uint32_t, int64_t, uint64_t
from libc.stddef cimport wchar_t
from libcpp.vector cimport vector
from cpython.buffer cimport PyObject_CheckBuffer, PyObject_GetBuffer, PyBuffer_Release, PyBUF_SIMPLE, PyBUF_ANY_CONTIGUOUS

ctypedef unsigned long long signed_char_ptr
ctypedef unsigned long long unsigned_char_ptr
ctypedef unsigned long long char_ptr
ctypedef unsigned long long short_ptr
ctypedef unsigned long long unsigned_short_ptr
ctypedef unsigned long long int_ptr
ctypedef unsigned long long long_int_ptr
ctypedef unsigned long long long_long_int_ptr
ctypedef unsigned long long unsigned_int_ptr
ctypedef unsigned long long unsigned_long_int_ptr
ctypedef unsigned long long unsigned_long_long_int_ptr
ctypedef unsigned long long uint32_t_ptr
ctypedef unsigned long long uint64_t_ptr
ctypedef unsigned long long int32_t_ptr
ctypedef unsigned long long int64_t_ptr
ctypedef unsigned long long unsigned_ptr
ctypedef unsigned long long unsigned_long_long_ptr
ctypedef unsigned long long size_t_ptr
ctypedef unsigned long long float_ptr
ctypedef unsigned long long double_ptr
ctypedef unsigned long long void_ptr

CUDA_VERSION = ccuda.CUDA_VERSION
CU_IPC_HANDLE_SIZE = ccuda.CU_IPC_HANDLE_SIZE
CU_STREAM_LEGACY = ccuda.CU_STREAM_LEGACY
CU_STREAM_PER_THREAD = ccuda.CU_STREAM_PER_THREAD
CU_MEMHOSTALLOC_PORTABLE = ccuda.CU_MEMHOSTALLOC_PORTABLE
CU_MEMHOSTALLOC_DEVICEMAP = ccuda.CU_MEMHOSTALLOC_DEVICEMAP
CU_MEMHOSTALLOC_WRITECOMBINED = ccuda.CU_MEMHOSTALLOC_WRITECOMBINED
CU_MEMHOSTREGISTER_PORTABLE = ccuda.CU_MEMHOSTREGISTER_PORTABLE
CU_MEMHOSTREGISTER_DEVICEMAP = ccuda.CU_MEMHOSTREGISTER_DEVICEMAP
CU_MEMHOSTREGISTER_IOMEMORY = ccuda.CU_MEMHOSTREGISTER_IOMEMORY
CU_MEMHOSTREGISTER_READ_ONLY = ccuda.CU_MEMHOSTREGISTER_READ_ONLY
CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL = ccuda.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL
CUDA_EXTERNAL_MEMORY_DEDICATED = ccuda.CUDA_EXTERNAL_MEMORY_DEDICATED
CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC = ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC
CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC = ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC
CUDA_NVSCISYNC_ATTR_SIGNAL = ccuda.CUDA_NVSCISYNC_ATTR_SIGNAL
CUDA_NVSCISYNC_ATTR_WAIT = ccuda.CUDA_NVSCISYNC_ATTR_WAIT
CU_MEM_CREATE_USAGE_TILE_POOL = ccuda.CU_MEM_CREATE_USAGE_TILE_POOL
CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC = ccuda.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC
CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC = ccuda.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC
CUDA_ARRAY3D_LAYERED = ccuda.CUDA_ARRAY3D_LAYERED
CUDA_ARRAY3D_2DARRAY = ccuda.CUDA_ARRAY3D_2DARRAY
CUDA_ARRAY3D_SURFACE_LDST = ccuda.CUDA_ARRAY3D_SURFACE_LDST
CUDA_ARRAY3D_CUBEMAP = ccuda.CUDA_ARRAY3D_CUBEMAP
CUDA_ARRAY3D_TEXTURE_GATHER = ccuda.CUDA_ARRAY3D_TEXTURE_GATHER
CUDA_ARRAY3D_DEPTH_TEXTURE = ccuda.CUDA_ARRAY3D_DEPTH_TEXTURE
CUDA_ARRAY3D_COLOR_ATTACHMENT = ccuda.CUDA_ARRAY3D_COLOR_ATTACHMENT
CUDA_ARRAY3D_SPARSE = ccuda.CUDA_ARRAY3D_SPARSE
CU_TRSA_OVERRIDE_FORMAT = ccuda.CU_TRSA_OVERRIDE_FORMAT
CU_TRSF_READ_AS_INTEGER = ccuda.CU_TRSF_READ_AS_INTEGER
CU_TRSF_NORMALIZED_COORDINATES = ccuda.CU_TRSF_NORMALIZED_COORDINATES
CU_TRSF_SRGB = ccuda.CU_TRSF_SRGB
CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION = ccuda.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION
CU_LAUNCH_PARAM_END = ccuda.CU_LAUNCH_PARAM_END
CU_LAUNCH_PARAM_BUFFER_POINTER = ccuda.CU_LAUNCH_PARAM_BUFFER_POINTER
CU_LAUNCH_PARAM_BUFFER_SIZE = ccuda.CU_LAUNCH_PARAM_BUFFER_SIZE
CU_PARAM_TR_DEFAULT = ccuda.CU_PARAM_TR_DEFAULT
CU_DEVICE_CPU = ccuda.CU_DEVICE_CPU
CU_DEVICE_INVALID = ccuda.CU_DEVICE_INVALID

class CUipcMem_flags(Enum):
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = ccuda.CUipcMem_flags_enum.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS

class CUmemAttach_flags(Enum):
    CU_MEM_ATTACH_GLOBAL = ccuda.CUmemAttach_flags_enum.CU_MEM_ATTACH_GLOBAL
    CU_MEM_ATTACH_HOST = ccuda.CUmemAttach_flags_enum.CU_MEM_ATTACH_HOST
    CU_MEM_ATTACH_SINGLE = ccuda.CUmemAttach_flags_enum.CU_MEM_ATTACH_SINGLE

class CUctx_flags(Enum):
    CU_CTX_SCHED_AUTO = ccuda.CUctx_flags_enum.CU_CTX_SCHED_AUTO
    CU_CTX_SCHED_SPIN = ccuda.CUctx_flags_enum.CU_CTX_SCHED_SPIN
    CU_CTX_SCHED_YIELD = ccuda.CUctx_flags_enum.CU_CTX_SCHED_YIELD
    CU_CTX_SCHED_BLOCKING_SYNC = ccuda.CUctx_flags_enum.CU_CTX_SCHED_BLOCKING_SYNC
    CU_CTX_BLOCKING_SYNC = ccuda.CUctx_flags_enum.CU_CTX_BLOCKING_SYNC
    CU_CTX_SCHED_MASK = ccuda.CUctx_flags_enum.CU_CTX_SCHED_MASK
    CU_CTX_MAP_HOST = ccuda.CUctx_flags_enum.CU_CTX_MAP_HOST
    CU_CTX_LMEM_RESIZE_TO_MAX = ccuda.CUctx_flags_enum.CU_CTX_LMEM_RESIZE_TO_MAX
    CU_CTX_FLAGS_MASK = ccuda.CUctx_flags_enum.CU_CTX_FLAGS_MASK

class CUstream_flags(Enum):
    CU_STREAM_DEFAULT = ccuda.CUstream_flags_enum.CU_STREAM_DEFAULT
    CU_STREAM_NON_BLOCKING = ccuda.CUstream_flags_enum.CU_STREAM_NON_BLOCKING

class CUevent_flags(Enum):
    CU_EVENT_DEFAULT = ccuda.CUevent_flags_enum.CU_EVENT_DEFAULT
    CU_EVENT_BLOCKING_SYNC = ccuda.CUevent_flags_enum.CU_EVENT_BLOCKING_SYNC
    CU_EVENT_DISABLE_TIMING = ccuda.CUevent_flags_enum.CU_EVENT_DISABLE_TIMING
    CU_EVENT_INTERPROCESS = ccuda.CUevent_flags_enum.CU_EVENT_INTERPROCESS

class CUevent_record_flags(Enum):
    CU_EVENT_RECORD_DEFAULT = ccuda.CUevent_record_flags_enum.CU_EVENT_RECORD_DEFAULT
    CU_EVENT_RECORD_EXTERNAL = ccuda.CUevent_record_flags_enum.CU_EVENT_RECORD_EXTERNAL

class CUevent_wait_flags(Enum):
    CU_EVENT_WAIT_DEFAULT = ccuda.CUevent_wait_flags_enum.CU_EVENT_WAIT_DEFAULT
    CU_EVENT_WAIT_EXTERNAL = ccuda.CUevent_wait_flags_enum.CU_EVENT_WAIT_EXTERNAL

class CUstreamWaitValue_flags(Enum):
    CU_STREAM_WAIT_VALUE_GEQ = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_GEQ
    CU_STREAM_WAIT_VALUE_EQ = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_EQ
    CU_STREAM_WAIT_VALUE_AND = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_AND
    CU_STREAM_WAIT_VALUE_NOR = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_NOR
    CU_STREAM_WAIT_VALUE_FLUSH = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_FLUSH

class CUstreamWriteValue_flags(Enum):
    CU_STREAM_WRITE_VALUE_DEFAULT = ccuda.CUstreamWriteValue_flags_enum.CU_STREAM_WRITE_VALUE_DEFAULT
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = ccuda.CUstreamWriteValue_flags_enum.CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER

class CUstreamBatchMemOpType(Enum):
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WAIT_VALUE_32
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WRITE_VALUE_32
    CU_STREAM_MEM_OP_WAIT_VALUE_64 = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WAIT_VALUE_64
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WRITE_VALUE_64
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES

class CUoccupancy_flags(Enum):
    CU_OCCUPANCY_DEFAULT = ccuda.CUoccupancy_flags_enum.CU_OCCUPANCY_DEFAULT
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = ccuda.CUoccupancy_flags_enum.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE

class CUstreamUpdateCaptureDependencies_flags(Enum):
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES = ccuda.CUstreamUpdateCaptureDependencies_flags_enum.CU_STREAM_ADD_CAPTURE_DEPENDENCIES
    CU_STREAM_SET_CAPTURE_DEPENDENCIES = ccuda.CUstreamUpdateCaptureDependencies_flags_enum.CU_STREAM_SET_CAPTURE_DEPENDENCIES

class CUarray_format(Enum):
    CU_AD_FORMAT_UNSIGNED_INT8 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT8
    CU_AD_FORMAT_UNSIGNED_INT16 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT16
    CU_AD_FORMAT_UNSIGNED_INT32 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT32
    CU_AD_FORMAT_SIGNED_INT8 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT8
    CU_AD_FORMAT_SIGNED_INT16 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT16
    CU_AD_FORMAT_SIGNED_INT32 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT32
    CU_AD_FORMAT_HALF = ccuda.CUarray_format_enum.CU_AD_FORMAT_HALF
    CU_AD_FORMAT_FLOAT = ccuda.CUarray_format_enum.CU_AD_FORMAT_FLOAT
    CU_AD_FORMAT_NV12 = ccuda.CUarray_format_enum.CU_AD_FORMAT_NV12

class CUaddress_mode(Enum):
    CU_TR_ADDRESS_MODE_WRAP = ccuda.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_WRAP
    CU_TR_ADDRESS_MODE_CLAMP = ccuda.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_CLAMP
    CU_TR_ADDRESS_MODE_MIRROR = ccuda.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_MIRROR
    CU_TR_ADDRESS_MODE_BORDER = ccuda.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_BORDER

class CUfilter_mode(Enum):
    CU_TR_FILTER_MODE_POINT = ccuda.CUfilter_mode_enum.CU_TR_FILTER_MODE_POINT
    CU_TR_FILTER_MODE_LINEAR = ccuda.CUfilter_mode_enum.CU_TR_FILTER_MODE_LINEAR

class CUdevice_attribute(Enum):
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_WARP_SIZE
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_PITCH
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CLOCK_RATE
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_OVERLAP
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT
    CU_DEVICE_ATTRIBUTE_INTEGRATED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_INTEGRATED
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_ECC_ENABLED
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TCC_DRIVER
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED
    CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES
    CU_DEVICE_ATTRIBUTE_MAX = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX

class CUpointer_attribute(Enum):
    CU_POINTER_ATTRIBUTE_CONTEXT = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_CONTEXT
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MEMORY_TYPE
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_DEVICE_POINTER
    CU_POINTER_ATTRIBUTE_HOST_POINTER = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_HOST_POINTER
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_P2P_TOKENS
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS
    CU_POINTER_ATTRIBUTE_BUFFER_ID = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_BUFFER_ID
    CU_POINTER_ATTRIBUTE_IS_MANAGED = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_MANAGED
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR
    CU_POINTER_ATTRIBUTE_RANGE_SIZE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_RANGE_SIZE
    CU_POINTER_ATTRIBUTE_MAPPED = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MAPPED
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAGS
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE

class CUfunction_attribute(Enum):
    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK
    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES
    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES
    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES
    CU_FUNC_ATTRIBUTE_NUM_REGS = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_NUM_REGS
    CU_FUNC_ATTRIBUTE_PTX_VERSION = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_PTX_VERSION
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_BINARY_VERSION
    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_CACHE_MODE_CA
    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT
    CU_FUNC_ATTRIBUTE_MAX = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX

class CUfunc_cache(Enum):
    CU_FUNC_CACHE_PREFER_NONE = ccuda.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_NONE
    CU_FUNC_CACHE_PREFER_SHARED = ccuda.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_SHARED
    CU_FUNC_CACHE_PREFER_L1 = ccuda.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_L1
    CU_FUNC_CACHE_PREFER_EQUAL = ccuda.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_EQUAL

class CUsharedconfig(Enum):
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = ccuda.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = ccuda.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = ccuda.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE

class CUshared_carveout(Enum):
    CU_SHAREDMEM_CARVEOUT_DEFAULT = ccuda.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_DEFAULT
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED = ccuda.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_MAX_SHARED
    CU_SHAREDMEM_CARVEOUT_MAX_L1 = ccuda.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_MAX_L1

class CUmemorytype(Enum):
    CU_MEMORYTYPE_HOST = ccuda.CUmemorytype_enum.CU_MEMORYTYPE_HOST
    CU_MEMORYTYPE_DEVICE = ccuda.CUmemorytype_enum.CU_MEMORYTYPE_DEVICE
    CU_MEMORYTYPE_ARRAY = ccuda.CUmemorytype_enum.CU_MEMORYTYPE_ARRAY
    CU_MEMORYTYPE_UNIFIED = ccuda.CUmemorytype_enum.CU_MEMORYTYPE_UNIFIED

class CUcomputemode(Enum):
    CU_COMPUTEMODE_DEFAULT = ccuda.CUcomputemode_enum.CU_COMPUTEMODE_DEFAULT
    CU_COMPUTEMODE_PROHIBITED = ccuda.CUcomputemode_enum.CU_COMPUTEMODE_PROHIBITED
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = ccuda.CUcomputemode_enum.CU_COMPUTEMODE_EXCLUSIVE_PROCESS

class CUmem_advise(Enum):
    CU_MEM_ADVISE_SET_READ_MOSTLY = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_SET_READ_MOSTLY
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_READ_MOSTLY
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_SET_PREFERRED_LOCATION
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION
    CU_MEM_ADVISE_SET_ACCESSED_BY = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_SET_ACCESSED_BY
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_ACCESSED_BY

class CUmem_range_attribute(Enum):
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = ccuda.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = ccuda.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = ccuda.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = ccuda.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION

class CUjit_option(Enum):
    CU_JIT_MAX_REGISTERS = ccuda.CUjit_option_enum.CU_JIT_MAX_REGISTERS
    CU_JIT_THREADS_PER_BLOCK = ccuda.CUjit_option_enum.CU_JIT_THREADS_PER_BLOCK
    CU_JIT_WALL_TIME = ccuda.CUjit_option_enum.CU_JIT_WALL_TIME
    CU_JIT_INFO_LOG_BUFFER = ccuda.CUjit_option_enum.CU_JIT_INFO_LOG_BUFFER
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = ccuda.CUjit_option_enum.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES
    CU_JIT_ERROR_LOG_BUFFER = ccuda.CUjit_option_enum.CU_JIT_ERROR_LOG_BUFFER
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = ccuda.CUjit_option_enum.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES
    CU_JIT_OPTIMIZATION_LEVEL = ccuda.CUjit_option_enum.CU_JIT_OPTIMIZATION_LEVEL
    CU_JIT_TARGET_FROM_CUCONTEXT = ccuda.CUjit_option_enum.CU_JIT_TARGET_FROM_CUCONTEXT
    CU_JIT_TARGET = ccuda.CUjit_option_enum.CU_JIT_TARGET
    CU_JIT_FALLBACK_STRATEGY = ccuda.CUjit_option_enum.CU_JIT_FALLBACK_STRATEGY
    CU_JIT_GENERATE_DEBUG_INFO = ccuda.CUjit_option_enum.CU_JIT_GENERATE_DEBUG_INFO
    CU_JIT_LOG_VERBOSE = ccuda.CUjit_option_enum.CU_JIT_LOG_VERBOSE
    CU_JIT_GENERATE_LINE_INFO = ccuda.CUjit_option_enum.CU_JIT_GENERATE_LINE_INFO
    CU_JIT_CACHE_MODE = ccuda.CUjit_option_enum.CU_JIT_CACHE_MODE
    CU_JIT_NEW_SM3X_OPT = ccuda.CUjit_option_enum.CU_JIT_NEW_SM3X_OPT
    CU_JIT_FAST_COMPILE = ccuda.CUjit_option_enum.CU_JIT_FAST_COMPILE
    CU_JIT_GLOBAL_SYMBOL_NAMES = ccuda.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_NAMES
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = ccuda.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_ADDRESSES
    CU_JIT_GLOBAL_SYMBOL_COUNT = ccuda.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_COUNT
    CU_JIT_LTO = ccuda.CUjit_option_enum.CU_JIT_LTO
    CU_JIT_FTZ = ccuda.CUjit_option_enum.CU_JIT_FTZ
    CU_JIT_PREC_DIV = ccuda.CUjit_option_enum.CU_JIT_PREC_DIV
    CU_JIT_PREC_SQRT = ccuda.CUjit_option_enum.CU_JIT_PREC_SQRT
    CU_JIT_FMA = ccuda.CUjit_option_enum.CU_JIT_FMA
    CU_JIT_NUM_OPTIONS = ccuda.CUjit_option_enum.CU_JIT_NUM_OPTIONS

class CUjit_target(Enum):
    CU_TARGET_COMPUTE_20 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_20
    CU_TARGET_COMPUTE_21 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_21
    CU_TARGET_COMPUTE_30 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_30
    CU_TARGET_COMPUTE_32 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_32
    CU_TARGET_COMPUTE_35 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_35
    CU_TARGET_COMPUTE_37 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_37
    CU_TARGET_COMPUTE_50 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_50
    CU_TARGET_COMPUTE_52 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_52
    CU_TARGET_COMPUTE_53 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_53
    CU_TARGET_COMPUTE_60 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_60
    CU_TARGET_COMPUTE_61 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_61
    CU_TARGET_COMPUTE_62 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_62
    CU_TARGET_COMPUTE_70 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_70
    CU_TARGET_COMPUTE_72 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_72
    CU_TARGET_COMPUTE_75 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_75
    CU_TARGET_COMPUTE_80 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_80
    CU_TARGET_COMPUTE_86 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_86

class CUjit_fallback(Enum):
    CU_PREFER_PTX = ccuda.CUjit_fallback_enum.CU_PREFER_PTX
    CU_PREFER_BINARY = ccuda.CUjit_fallback_enum.CU_PREFER_BINARY

class CUjit_cacheMode(Enum):
    CU_JIT_CACHE_OPTION_NONE = ccuda.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_NONE
    CU_JIT_CACHE_OPTION_CG = ccuda.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_CG
    CU_JIT_CACHE_OPTION_CA = ccuda.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_CA

class CUjitInputType(Enum):
    CU_JIT_INPUT_CUBIN = ccuda.CUjitInputType_enum.CU_JIT_INPUT_CUBIN
    CU_JIT_INPUT_PTX = ccuda.CUjitInputType_enum.CU_JIT_INPUT_PTX
    CU_JIT_INPUT_FATBINARY = ccuda.CUjitInputType_enum.CU_JIT_INPUT_FATBINARY
    CU_JIT_INPUT_OBJECT = ccuda.CUjitInputType_enum.CU_JIT_INPUT_OBJECT
    CU_JIT_INPUT_LIBRARY = ccuda.CUjitInputType_enum.CU_JIT_INPUT_LIBRARY
    CU_JIT_INPUT_NVVM = ccuda.CUjitInputType_enum.CU_JIT_INPUT_NVVM
    CU_JIT_NUM_INPUT_TYPES = ccuda.CUjitInputType_enum.CU_JIT_NUM_INPUT_TYPES

class CUgraphicsRegisterFlags(Enum):
    CU_GRAPHICS_REGISTER_FLAGS_NONE = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_NONE
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER

class CUgraphicsMapResourceFlags(Enum):
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = ccuda.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = ccuda.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = ccuda.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD

class CUarray_cubemap_face(Enum):
    CU_CUBEMAP_FACE_POSITIVE_X = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_X
    CU_CUBEMAP_FACE_NEGATIVE_X = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_X
    CU_CUBEMAP_FACE_POSITIVE_Y = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_Y
    CU_CUBEMAP_FACE_NEGATIVE_Y = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_Y
    CU_CUBEMAP_FACE_POSITIVE_Z = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_Z
    CU_CUBEMAP_FACE_NEGATIVE_Z = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_Z

class CUlimit(Enum):
    CU_LIMIT_STACK_SIZE = ccuda.CUlimit_enum.CU_LIMIT_STACK_SIZE
    CU_LIMIT_PRINTF_FIFO_SIZE = ccuda.CUlimit_enum.CU_LIMIT_PRINTF_FIFO_SIZE
    CU_LIMIT_MALLOC_HEAP_SIZE = ccuda.CUlimit_enum.CU_LIMIT_MALLOC_HEAP_SIZE
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = ccuda.CUlimit_enum.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = ccuda.CUlimit_enum.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY = ccuda.CUlimit_enum.CU_LIMIT_MAX_L2_FETCH_GRANULARITY
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE = ccuda.CUlimit_enum.CU_LIMIT_PERSISTING_L2_CACHE_SIZE
    CU_LIMIT_MAX = ccuda.CUlimit_enum.CU_LIMIT_MAX

class CUresourcetype(Enum):
    CU_RESOURCE_TYPE_ARRAY = ccuda.CUresourcetype_enum.CU_RESOURCE_TYPE_ARRAY
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = ccuda.CUresourcetype_enum.CU_RESOURCE_TYPE_MIPMAPPED_ARRAY
    CU_RESOURCE_TYPE_LINEAR = ccuda.CUresourcetype_enum.CU_RESOURCE_TYPE_LINEAR
    CU_RESOURCE_TYPE_PITCH2D = ccuda.CUresourcetype_enum.CU_RESOURCE_TYPE_PITCH2D

class CUaccessProperty(Enum):
    CU_ACCESS_PROPERTY_NORMAL = ccuda.CUaccessProperty_enum.CU_ACCESS_PROPERTY_NORMAL
    CU_ACCESS_PROPERTY_STREAMING = ccuda.CUaccessProperty_enum.CU_ACCESS_PROPERTY_STREAMING
    CU_ACCESS_PROPERTY_PERSISTING = ccuda.CUaccessProperty_enum.CU_ACCESS_PROPERTY_PERSISTING

class CUgraphNodeType(Enum):
    CU_GRAPH_NODE_TYPE_KERNEL = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_KERNEL
    CU_GRAPH_NODE_TYPE_MEMCPY = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEMCPY
    CU_GRAPH_NODE_TYPE_MEMSET = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEMSET
    CU_GRAPH_NODE_TYPE_HOST = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_HOST
    CU_GRAPH_NODE_TYPE_GRAPH = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_GRAPH
    CU_GRAPH_NODE_TYPE_EMPTY = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EMPTY
    CU_GRAPH_NODE_TYPE_WAIT_EVENT = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_WAIT_EVENT
    CU_GRAPH_NODE_TYPE_EVENT_RECORD = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EVENT_RECORD
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT
    CU_GRAPH_NODE_TYPE_MEM_ALLOC = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEM_ALLOC
    CU_GRAPH_NODE_TYPE_MEM_FREE = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEM_FREE

class CUsynchronizationPolicy(Enum):
    CU_SYNC_POLICY_AUTO = ccuda.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_AUTO
    CU_SYNC_POLICY_SPIN = ccuda.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_SPIN
    CU_SYNC_POLICY_YIELD = ccuda.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_YIELD
    CU_SYNC_POLICY_BLOCKING_SYNC = ccuda.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_BLOCKING_SYNC

class CUkernelNodeAttrID(Enum):
    CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW = ccuda.CUkernelNodeAttrID_enum.CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW
    CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE = ccuda.CUkernelNodeAttrID_enum.CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE

class CUstreamCaptureStatus(Enum):
    CU_STREAM_CAPTURE_STATUS_NONE = ccuda.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_NONE
    CU_STREAM_CAPTURE_STATUS_ACTIVE = ccuda.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_ACTIVE
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = ccuda.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_INVALIDATED

class CUstreamCaptureMode(Enum):
    CU_STREAM_CAPTURE_MODE_GLOBAL = ccuda.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_GLOBAL
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = ccuda.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_THREAD_LOCAL
    CU_STREAM_CAPTURE_MODE_RELAXED = ccuda.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_RELAXED

class CUstreamAttrID(Enum):
    CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW = ccuda.CUstreamAttrID_enum.CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW
    CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY = ccuda.CUstreamAttrID_enum.CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY

class CUdriverProcAddress_flags(Enum):
    CU_GET_PROC_ADDRESS_DEFAULT = ccuda.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_DEFAULT
    CU_GET_PROC_ADDRESS_LEGACY_STREAM = ccuda.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_LEGACY_STREAM
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = ccuda.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM

class CUexecAffinityType(Enum):
    CU_EXEC_AFFINITY_TYPE_SM_COUNT = ccuda.CUexecAffinityType_enum.CU_EXEC_AFFINITY_TYPE_SM_COUNT
    CU_EXEC_AFFINITY_TYPE_MAX = ccuda.CUexecAffinityType_enum.CU_EXEC_AFFINITY_TYPE_MAX

class CUresult(Enum):
    CUDA_SUCCESS = ccuda.cudaError_enum.CUDA_SUCCESS
    CUDA_ERROR_INVALID_VALUE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_VALUE
    CUDA_ERROR_OUT_OF_MEMORY = ccuda.cudaError_enum.CUDA_ERROR_OUT_OF_MEMORY
    CUDA_ERROR_NOT_INITIALIZED = ccuda.cudaError_enum.CUDA_ERROR_NOT_INITIALIZED
    CUDA_ERROR_DEINITIALIZED = ccuda.cudaError_enum.CUDA_ERROR_DEINITIALIZED
    CUDA_ERROR_PROFILER_DISABLED = ccuda.cudaError_enum.CUDA_ERROR_PROFILER_DISABLED
    CUDA_ERROR_PROFILER_NOT_INITIALIZED = ccuda.cudaError_enum.CUDA_ERROR_PROFILER_NOT_INITIALIZED
    CUDA_ERROR_PROFILER_ALREADY_STARTED = ccuda.cudaError_enum.CUDA_ERROR_PROFILER_ALREADY_STARTED
    CUDA_ERROR_PROFILER_ALREADY_STOPPED = ccuda.cudaError_enum.CUDA_ERROR_PROFILER_ALREADY_STOPPED
    CUDA_ERROR_STUB_LIBRARY = ccuda.cudaError_enum.CUDA_ERROR_STUB_LIBRARY
    CUDA_ERROR_NO_DEVICE = ccuda.cudaError_enum.CUDA_ERROR_NO_DEVICE
    CUDA_ERROR_INVALID_DEVICE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_DEVICE
    CUDA_ERROR_DEVICE_NOT_LICENSED = ccuda.cudaError_enum.CUDA_ERROR_DEVICE_NOT_LICENSED
    CUDA_ERROR_INVALID_IMAGE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_IMAGE
    CUDA_ERROR_INVALID_CONTEXT = ccuda.cudaError_enum.CUDA_ERROR_INVALID_CONTEXT
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = ccuda.cudaError_enum.CUDA_ERROR_CONTEXT_ALREADY_CURRENT
    CUDA_ERROR_MAP_FAILED = ccuda.cudaError_enum.CUDA_ERROR_MAP_FAILED
    CUDA_ERROR_UNMAP_FAILED = ccuda.cudaError_enum.CUDA_ERROR_UNMAP_FAILED
    CUDA_ERROR_ARRAY_IS_MAPPED = ccuda.cudaError_enum.CUDA_ERROR_ARRAY_IS_MAPPED
    CUDA_ERROR_ALREADY_MAPPED = ccuda.cudaError_enum.CUDA_ERROR_ALREADY_MAPPED
    CUDA_ERROR_NO_BINARY_FOR_GPU = ccuda.cudaError_enum.CUDA_ERROR_NO_BINARY_FOR_GPU
    CUDA_ERROR_ALREADY_ACQUIRED = ccuda.cudaError_enum.CUDA_ERROR_ALREADY_ACQUIRED
    CUDA_ERROR_NOT_MAPPED = ccuda.cudaError_enum.CUDA_ERROR_NOT_MAPPED
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = ccuda.cudaError_enum.CUDA_ERROR_NOT_MAPPED_AS_ARRAY
    CUDA_ERROR_NOT_MAPPED_AS_POINTER = ccuda.cudaError_enum.CUDA_ERROR_NOT_MAPPED_AS_POINTER
    CUDA_ERROR_ECC_UNCORRECTABLE = ccuda.cudaError_enum.CUDA_ERROR_ECC_UNCORRECTABLE
    CUDA_ERROR_UNSUPPORTED_LIMIT = ccuda.cudaError_enum.CUDA_ERROR_UNSUPPORTED_LIMIT
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = ccuda.cudaError_enum.CUDA_ERROR_CONTEXT_ALREADY_IN_USE
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = ccuda.cudaError_enum.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED
    CUDA_ERROR_INVALID_PTX = ccuda.cudaError_enum.CUDA_ERROR_INVALID_PTX
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = ccuda.cudaError_enum.CUDA_ERROR_INVALID_GRAPHICS_CONTEXT
    CUDA_ERROR_NVLINK_UNCORRECTABLE = ccuda.cudaError_enum.CUDA_ERROR_NVLINK_UNCORRECTABLE
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND = ccuda.cudaError_enum.CUDA_ERROR_JIT_COMPILER_NOT_FOUND
    CUDA_ERROR_UNSUPPORTED_PTX_VERSION = ccuda.cudaError_enum.CUDA_ERROR_UNSUPPORTED_PTX_VERSION
    CUDA_ERROR_JIT_COMPILATION_DISABLED = ccuda.cudaError_enum.CUDA_ERROR_JIT_COMPILATION_DISABLED
    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY = ccuda.cudaError_enum.CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY
    CUDA_ERROR_INVALID_SOURCE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_SOURCE
    CUDA_ERROR_FILE_NOT_FOUND = ccuda.cudaError_enum.CUDA_ERROR_FILE_NOT_FOUND
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = ccuda.cudaError_enum.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = ccuda.cudaError_enum.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED
    CUDA_ERROR_OPERATING_SYSTEM = ccuda.cudaError_enum.CUDA_ERROR_OPERATING_SYSTEM
    CUDA_ERROR_INVALID_HANDLE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_HANDLE
    CUDA_ERROR_ILLEGAL_STATE = ccuda.cudaError_enum.CUDA_ERROR_ILLEGAL_STATE
    CUDA_ERROR_NOT_FOUND = ccuda.cudaError_enum.CUDA_ERROR_NOT_FOUND
    CUDA_ERROR_NOT_READY = ccuda.cudaError_enum.CUDA_ERROR_NOT_READY
    CUDA_ERROR_ILLEGAL_ADDRESS = ccuda.cudaError_enum.CUDA_ERROR_ILLEGAL_ADDRESS
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = ccuda.cudaError_enum.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES
    CUDA_ERROR_LAUNCH_TIMEOUT = ccuda.cudaError_enum.CUDA_ERROR_LAUNCH_TIMEOUT
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = ccuda.cudaError_enum.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = ccuda.cudaError_enum.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = ccuda.cudaError_enum.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = ccuda.cudaError_enum.CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE
    CUDA_ERROR_CONTEXT_IS_DESTROYED = ccuda.cudaError_enum.CUDA_ERROR_CONTEXT_IS_DESTROYED
    CUDA_ERROR_ASSERT = ccuda.cudaError_enum.CUDA_ERROR_ASSERT
    CUDA_ERROR_TOO_MANY_PEERS = ccuda.cudaError_enum.CUDA_ERROR_TOO_MANY_PEERS
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = ccuda.cudaError_enum.CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = ccuda.cudaError_enum.CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED
    CUDA_ERROR_HARDWARE_STACK_ERROR = ccuda.cudaError_enum.CUDA_ERROR_HARDWARE_STACK_ERROR
    CUDA_ERROR_ILLEGAL_INSTRUCTION = ccuda.cudaError_enum.CUDA_ERROR_ILLEGAL_INSTRUCTION
    CUDA_ERROR_MISALIGNED_ADDRESS = ccuda.cudaError_enum.CUDA_ERROR_MISALIGNED_ADDRESS
    CUDA_ERROR_INVALID_ADDRESS_SPACE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_ADDRESS_SPACE
    CUDA_ERROR_INVALID_PC = ccuda.cudaError_enum.CUDA_ERROR_INVALID_PC
    CUDA_ERROR_LAUNCH_FAILED = ccuda.cudaError_enum.CUDA_ERROR_LAUNCH_FAILED
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = ccuda.cudaError_enum.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE
    CUDA_ERROR_NOT_PERMITTED = ccuda.cudaError_enum.CUDA_ERROR_NOT_PERMITTED
    CUDA_ERROR_NOT_SUPPORTED = ccuda.cudaError_enum.CUDA_ERROR_NOT_SUPPORTED
    CUDA_ERROR_SYSTEM_NOT_READY = ccuda.cudaError_enum.CUDA_ERROR_SYSTEM_NOT_READY
    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH = ccuda.cudaError_enum.CUDA_ERROR_SYSTEM_DRIVER_MISMATCH
    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = ccuda.cudaError_enum.CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE
    CUDA_ERROR_MPS_CONNECTION_FAILED = ccuda.cudaError_enum.CUDA_ERROR_MPS_CONNECTION_FAILED
    CUDA_ERROR_MPS_RPC_FAILURE = ccuda.cudaError_enum.CUDA_ERROR_MPS_RPC_FAILURE
    CUDA_ERROR_MPS_SERVER_NOT_READY = ccuda.cudaError_enum.CUDA_ERROR_MPS_SERVER_NOT_READY
    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED = ccuda.cudaError_enum.CUDA_ERROR_MPS_MAX_CLIENTS_REACHED
    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED = ccuda.cudaError_enum.CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_INVALIDATED
    CUDA_ERROR_STREAM_CAPTURE_MERGE = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_MERGE
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNMATCHED
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNJOINED
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_ISOLATION
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT
    CUDA_ERROR_CAPTURED_EVENT = ccuda.cudaError_enum.CUDA_ERROR_CAPTURED_EVENT
    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD
    CUDA_ERROR_TIMEOUT = ccuda.cudaError_enum.CUDA_ERROR_TIMEOUT
    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE = ccuda.cudaError_enum.CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE
    CUDA_ERROR_UNKNOWN = ccuda.cudaError_enum.CUDA_ERROR_UNKNOWN

class CUdevice_P2PAttribute(Enum):
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED
    CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED

class CUresourceViewFormat(Enum):
    CU_RES_VIEW_FORMAT_NONE = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_NONE
    CU_RES_VIEW_FORMAT_UINT_1X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X8
    CU_RES_VIEW_FORMAT_UINT_2X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X8
    CU_RES_VIEW_FORMAT_UINT_4X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X8
    CU_RES_VIEW_FORMAT_SINT_1X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X8
    CU_RES_VIEW_FORMAT_SINT_2X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X8
    CU_RES_VIEW_FORMAT_SINT_4X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X8
    CU_RES_VIEW_FORMAT_UINT_1X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X16
    CU_RES_VIEW_FORMAT_UINT_2X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X16
    CU_RES_VIEW_FORMAT_UINT_4X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X16
    CU_RES_VIEW_FORMAT_SINT_1X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X16
    CU_RES_VIEW_FORMAT_SINT_2X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X16
    CU_RES_VIEW_FORMAT_SINT_4X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X16
    CU_RES_VIEW_FORMAT_UINT_1X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X32
    CU_RES_VIEW_FORMAT_UINT_2X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X32
    CU_RES_VIEW_FORMAT_UINT_4X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X32
    CU_RES_VIEW_FORMAT_SINT_1X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X32
    CU_RES_VIEW_FORMAT_SINT_2X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X32
    CU_RES_VIEW_FORMAT_SINT_4X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X32
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_1X16
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_2X16
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_4X16
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_1X32
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_2X32
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_4X32
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC1
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC2
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC3
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC4
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC4
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC5
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC5
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC6H
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC6H
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC7

class CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS(Enum):
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE = ccuda.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ = ccuda.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = ccuda.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE

class CUexternalMemoryHandleType(Enum):
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF

class CUexternalSemaphoreHandleType(Enum):
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32

class CUmemAllocationHandleType(Enum):
    CU_MEM_HANDLE_TYPE_NONE = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_NONE
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR
    CU_MEM_HANDLE_TYPE_WIN32 = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_WIN32
    CU_MEM_HANDLE_TYPE_WIN32_KMT = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_WIN32_KMT
    CU_MEM_HANDLE_TYPE_MAX = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_MAX

class CUmemAccess_flags(Enum):
    CU_MEM_ACCESS_FLAGS_PROT_NONE = ccuda.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_NONE
    CU_MEM_ACCESS_FLAGS_PROT_READ = ccuda.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_READ
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE = ccuda.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_READWRITE
    CU_MEM_ACCESS_FLAGS_PROT_MAX = ccuda.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_MAX

class CUmemLocationType(Enum):
    CU_MEM_LOCATION_TYPE_INVALID = ccuda.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_INVALID
    CU_MEM_LOCATION_TYPE_DEVICE = ccuda.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_DEVICE
    CU_MEM_LOCATION_TYPE_MAX = ccuda.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_MAX

class CUmemAllocationType(Enum):
    CU_MEM_ALLOCATION_TYPE_INVALID = ccuda.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_INVALID
    CU_MEM_ALLOCATION_TYPE_PINNED = ccuda.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_PINNED
    CU_MEM_ALLOCATION_TYPE_MAX = ccuda.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_MAX

class CUmemAllocationGranularity_flags(Enum):
    CU_MEM_ALLOC_GRANULARITY_MINIMUM = ccuda.CUmemAllocationGranularity_flags_enum.CU_MEM_ALLOC_GRANULARITY_MINIMUM
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = ccuda.CUmemAllocationGranularity_flags_enum.CU_MEM_ALLOC_GRANULARITY_RECOMMENDED

class CUarraySparseSubresourceType(Enum):
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = ccuda.CUarraySparseSubresourceType_enum.CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = ccuda.CUarraySparseSubresourceType_enum.CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL

class CUmemOperationType(Enum):
    CU_MEM_OPERATION_TYPE_MAP = ccuda.CUmemOperationType_enum.CU_MEM_OPERATION_TYPE_MAP
    CU_MEM_OPERATION_TYPE_UNMAP = ccuda.CUmemOperationType_enum.CU_MEM_OPERATION_TYPE_UNMAP

class CUmemHandleType(Enum):
    CU_MEM_HANDLE_TYPE_GENERIC = ccuda.CUmemHandleType_enum.CU_MEM_HANDLE_TYPE_GENERIC

class CUmemAllocationCompType(Enum):
    CU_MEM_ALLOCATION_COMP_NONE = ccuda.CUmemAllocationCompType_enum.CU_MEM_ALLOCATION_COMP_NONE
    CU_MEM_ALLOCATION_COMP_GENERIC = ccuda.CUmemAllocationCompType_enum.CU_MEM_ALLOCATION_COMP_GENERIC

class CUgraphExecUpdateResult(Enum):
    CU_GRAPH_EXEC_UPDATE_SUCCESS = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_SUCCESS
    CU_GRAPH_EXEC_UPDATE_ERROR = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE

class CUmemPool_attribute(Enum):
    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES
    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC
    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES
    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD
    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT
    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH
    CU_MEMPOOL_ATTR_USED_MEM_CURRENT = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_USED_MEM_CURRENT
    CU_MEMPOOL_ATTR_USED_MEM_HIGH = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_USED_MEM_HIGH

class CUgraphMem_attribute(Enum):
    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT = ccuda.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT
    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH = ccuda.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT = ccuda.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH = ccuda.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH

class CUflushGPUDirectRDMAWritesOptions(Enum):
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = ccuda.CUflushGPUDirectRDMAWritesOptions_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = ccuda.CUflushGPUDirectRDMAWritesOptions_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS

class CUGPUDirectRDMAWritesOrdering(Enum):
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE = ccuda.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = ccuda.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = ccuda.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES

class CUflushGPUDirectRDMAWritesScope(Enum):
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = ccuda.CUflushGPUDirectRDMAWritesScope_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = ccuda.CUflushGPUDirectRDMAWritesScope_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES

class CUflushGPUDirectRDMAWritesTarget(Enum):
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = ccuda.CUflushGPUDirectRDMAWritesTarget_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX

class CUgraphDebugDot_flags(Enum):
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS

class CUuserObject_flags(Enum):
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = ccuda.CUuserObject_flags_enum.CU_USER_OBJECT_NO_DESTRUCTOR_SYNC

class CUuserObjectRetain_flags(Enum):
    CU_GRAPH_USER_OBJECT_MOVE = ccuda.CUuserObjectRetain_flags_enum.CU_GRAPH_USER_OBJECT_MOVE

class CUgraphInstantiate_flags(Enum):
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = ccuda.CUgraphInstantiate_flags_enum.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH


cdef class CUcontext:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUcontext *>calloc(1, sizeof(ccuda.CUcontext))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUcontext)))
            self._ptr[0] = <ccuda.CUcontext>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUcontext *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUcontext ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmodule:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmodule *>calloc(1, sizeof(ccuda.CUmodule))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmodule)))
            self._ptr[0] = <ccuda.CUmodule>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmodule *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUmodule ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUfunction:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUfunction *>calloc(1, sizeof(ccuda.CUfunction))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUfunction)))
            self._ptr[0] = <ccuda.CUfunction>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUfunction *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUfunction ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUarray:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUarray *>calloc(1, sizeof(ccuda.CUarray))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUarray)))
            self._ptr[0] = <ccuda.CUarray>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUarray *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUarray ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmipmappedArray:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmipmappedArray *>calloc(1, sizeof(ccuda.CUmipmappedArray))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmipmappedArray)))
            self._ptr[0] = <ccuda.CUmipmappedArray>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmipmappedArray *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUmipmappedArray ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUtexref:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUtexref *>calloc(1, sizeof(ccuda.CUtexref))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUtexref)))
            self._ptr[0] = <ccuda.CUtexref>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUtexref *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUtexref ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUsurfref:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUsurfref *>calloc(1, sizeof(ccuda.CUsurfref))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUsurfref)))
            self._ptr[0] = <ccuda.CUsurfref>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUsurfref *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUsurfref ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUevent:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUevent *>calloc(1, sizeof(ccuda.CUevent))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUevent)))
            self._ptr[0] = <ccuda.CUevent>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUevent *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUevent ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUstream:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUstream *>calloc(1, sizeof(ccuda.CUstream))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUstream)))
            self._ptr[0] = <ccuda.CUstream>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUstream *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUstream ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUgraphicsResource:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUgraphicsResource *>calloc(1, sizeof(ccuda.CUgraphicsResource))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUgraphicsResource)))
            self._ptr[0] = <ccuda.CUgraphicsResource>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUgraphicsResource *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUgraphicsResource ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUexternalMemory:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUexternalMemory *>calloc(1, sizeof(ccuda.CUexternalMemory))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUexternalMemory)))
            self._ptr[0] = <ccuda.CUexternalMemory>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUexternalMemory *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUexternalMemory ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUexternalSemaphore:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUexternalSemaphore *>calloc(1, sizeof(ccuda.CUexternalSemaphore))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUexternalSemaphore)))
            self._ptr[0] = <ccuda.CUexternalSemaphore>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUexternalSemaphore *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUexternalSemaphore ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUgraph:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUgraph *>calloc(1, sizeof(ccuda.CUgraph))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUgraph)))
            self._ptr[0] = <ccuda.CUgraph>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUgraph *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUgraph ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUgraphNode:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUgraphNode *>calloc(1, sizeof(ccuda.CUgraphNode))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUgraphNode)))
            self._ptr[0] = <ccuda.CUgraphNode>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUgraphNode *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUgraphNode ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUgraphExec:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUgraphExec *>calloc(1, sizeof(ccuda.CUgraphExec))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUgraphExec)))
            self._ptr[0] = <ccuda.CUgraphExec>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUgraphExec *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUgraphExec ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmemoryPool:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmemoryPool *>calloc(1, sizeof(ccuda.CUmemoryPool))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmemoryPool)))
            self._ptr[0] = <ccuda.CUmemoryPool>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmemoryPool *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUmemoryPool ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUuserObject:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUuserObject *>calloc(1, sizeof(ccuda.CUuserObject))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUuserObject)))
            self._ptr[0] = <ccuda.CUuserObject>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUuserObject *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUuserObject ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUlinkState:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUlinkState *>calloc(1, sizeof(ccuda.CUlinkState))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUlinkState)))
            self._ptr[0] = <ccuda.CUlinkState>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUlinkState *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUlinkState ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUhostFn:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUhostFn *>calloc(1, sizeof(ccuda.CUhostFn))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUhostFn)))
            self._ptr[0] = <ccuda.CUhostFn>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUhostFn *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUhostFn ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUstreamCallback:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUstreamCallback *>calloc(1, sizeof(ccuda.CUstreamCallback))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUstreamCallback)))
            self._ptr[0] = <ccuda.CUstreamCallback>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUstreamCallback *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUstreamCallback ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUoccupancyB2DSize:
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUoccupancyB2DSize *>calloc(1, sizeof(ccuda.CUoccupancyB2DSize))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUoccupancyB2DSize)))
            self._ptr[0] = <ccuda.CUoccupancyB2DSize>init_value
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUoccupancyB2DSize *>_ptr
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUoccupancyB2DSize ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class cuuint32_t:
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.cuuint32_t *>calloc(1, sizeof(ccuda.cuuint32_t))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.cuuint32_t)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.cuuint32_t *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<cuuint32_t ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class cuuint64_t:
    def __cinit__(self, uint64_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.cuuint64_t *>calloc(1, sizeof(ccuda.cuuint64_t))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.cuuint64_t)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.cuuint64_t *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<cuuint64_t ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint64_t>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUdeviceptr_v2:
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUdeviceptr_v2 *>calloc(1, sizeof(ccuda.CUdeviceptr_v2))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUdeviceptr_v2)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUdeviceptr_v2 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUdeviceptr_v2 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUdeviceptr:
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUdeviceptr *>calloc(1, sizeof(ccuda.CUdeviceptr))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUdeviceptr)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUdeviceptr *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUdeviceptr ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUdevice_v1:
    def __cinit__(self, int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUdevice_v1 *>calloc(1, sizeof(ccuda.CUdevice_v1))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUdevice_v1)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUdevice_v1 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUdevice_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <int>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUdevice:
    def __cinit__(self, int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUdevice *>calloc(1, sizeof(ccuda.CUdevice))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUdevice)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUdevice *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUdevice ' + str(self.__int__()) + '>'
    def __int__(self):
        return <int>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUtexObject_v1:
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUtexObject_v1 *>calloc(1, sizeof(ccuda.CUtexObject_v1))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUtexObject_v1)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUtexObject_v1 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUtexObject_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUtexObject:
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUtexObject *>calloc(1, sizeof(ccuda.CUtexObject))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUtexObject)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUtexObject *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUtexObject ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUsurfObject_v1:
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUsurfObject_v1 *>calloc(1, sizeof(ccuda.CUsurfObject_v1))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUsurfObject_v1)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUsurfObject_v1 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUsurfObject_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUsurfObject:
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUsurfObject *>calloc(1, sizeof(ccuda.CUsurfObject))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUsurfObject)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUsurfObject *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUsurfObject ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmemGenericAllocationHandle_v1:
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmemGenericAllocationHandle_v1 *>calloc(1, sizeof(ccuda.CUmemGenericAllocationHandle_v1))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmemGenericAllocationHandle_v1)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmemGenericAllocationHandle_v1 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUmemGenericAllocationHandle_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmemGenericAllocationHandle:
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmemGenericAllocationHandle *>calloc(1, sizeof(ccuda.CUmemGenericAllocationHandle))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmemGenericAllocationHandle)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmemGenericAllocationHandle *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
    def __repr__(self):
        return '<CUmemGenericAllocationHandle ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUuuid_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUuuid_st *>calloc(1, sizeof(ccuda.CUuuid_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUuuid_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUuuid_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['bytes : ' + str(self.bytes.hex())]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def bytes(self):
        return self._ptr[0].bytes

cdef class CUipcEventHandle_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUipcEventHandle_st *>calloc(1, sizeof(ccuda.CUipcEventHandle_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUipcEventHandle_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUipcEventHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUipcMemHandle_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUipcMemHandle_st *>calloc(1, sizeof(ccuda.CUipcMemHandle_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUipcMemHandle_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUipcMemHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUstreamMemOpWaitValueParams_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUstreamMemOpWaitValueParams_st *>calloc(1, sizeof(ccuda.CUstreamMemOpWaitValueParams_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUstreamMemOpWaitValueParams_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUstreamMemOpWaitValueParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._address = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].address)
        self._value64 = cuuint64_t(_ptr=<void_ptr>&self._ptr[0].value64)
        self._alias = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].alias)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['address : ' + str(self.address)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['value64 : ' + str(self.value64)]
            str_list += ['alias : ' + str(self.alias)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def address(self):
        return self._address
    @address.setter
    def address(self, address : CUdeviceptr):
        pass
        self._address._ptr[0] = <ccuda.CUdeviceptr> NULL if address == None else (<CUdeviceptr>address)._ptr[0]
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def value64(self):
        return self._value64
    @value64.setter
    def value64(self, value64 : cuuint64_t):
        pass
        self._value64._ptr[0] = <ccuda.cuuint64_t> NULL if value64 == None else (<cuuint64_t>value64)._ptr[0]
    @property
    def alias(self):
        return self._alias
    @alias.setter
    def alias(self, alias : CUdeviceptr):
        pass
        self._alias._ptr[0] = <ccuda.CUdeviceptr> NULL if alias == None else (<CUdeviceptr>alias)._ptr[0]

cdef class CUstreamMemOpWriteValueParams_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUstreamMemOpWriteValueParams_st *>calloc(1, sizeof(ccuda.CUstreamMemOpWriteValueParams_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUstreamMemOpWriteValueParams_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUstreamMemOpWriteValueParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._address = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].address)
        self._value64 = cuuint64_t(_ptr=<void_ptr>&self._ptr[0].value64)
        self._alias = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].alias)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['address : ' + str(self.address)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['value64 : ' + str(self.value64)]
            str_list += ['alias : ' + str(self.alias)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def address(self):
        return self._address
    @address.setter
    def address(self, address : CUdeviceptr):
        pass
        self._address._ptr[0] = <ccuda.CUdeviceptr> NULL if address == None else (<CUdeviceptr>address)._ptr[0]
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def value64(self):
        return self._value64
    @value64.setter
    def value64(self, value64 : cuuint64_t):
        pass
        self._value64._ptr[0] = <ccuda.cuuint64_t> NULL if value64 == None else (<cuuint64_t>value64)._ptr[0]
    @property
    def alias(self):
        return self._alias
    @alias.setter
    def alias(self, alias : CUdeviceptr):
        pass
        self._alias._ptr[0] = <ccuda.CUdeviceptr> NULL if alias == None else (<CUdeviceptr>alias)._ptr[0]

cdef class CUstreamMemOpFlushRemoteWritesParams_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUstreamMemOpFlushRemoteWritesParams_st *>calloc(1, sizeof(ccuda.CUstreamMemOpFlushRemoteWritesParams_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUstreamMemOpFlushRemoteWritesParams_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUstreamMemOpFlushRemoteWritesParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['flags : ' + str(self.flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags

cdef class CUstreamBatchMemOpParams_union:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUstreamBatchMemOpParams_union *>calloc(1, sizeof(ccuda.CUstreamBatchMemOpParams_union))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUstreamBatchMemOpParams_union)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUstreamBatchMemOpParams_union *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._waitValue = CUstreamMemOpWaitValueParams_st(_ptr=<void_ptr>&self._ptr[0].waitValue)
        self._writeValue = CUstreamMemOpWriteValueParams_st(_ptr=<void_ptr>&self._ptr[0].writeValue)
        self._flushRemoteWrites = CUstreamMemOpFlushRemoteWritesParams_st(_ptr=<void_ptr>&self._ptr[0].flushRemoteWrites)
        self._pad = cuuint64_t(_ptr=<void_ptr>&self._ptr[0].pad)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['waitValue :\n' + '\n'.join(['    ' + line for line in str(self.waitValue).splitlines()])]
            str_list += ['writeValue :\n' + '\n'.join(['    ' + line for line in str(self.writeValue).splitlines()])]
            str_list += ['flushRemoteWrites :\n' + '\n'.join(['    ' + line for line in str(self.flushRemoteWrites).splitlines()])]
            str_list += ['pad : ' + str(self.pad)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def waitValue(self):
        return self._waitValue
    @waitValue.setter
    def waitValue(self, waitValue not None : CUstreamMemOpWaitValueParams_st):
        pass
        for _attr in dir(waitValue):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._waitValue, _attr, getattr(waitValue, _attr))
    @property
    def writeValue(self):
        return self._writeValue
    @writeValue.setter
    def writeValue(self, writeValue not None : CUstreamMemOpWriteValueParams_st):
        pass
        for _attr in dir(writeValue):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._writeValue, _attr, getattr(writeValue, _attr))
    @property
    def flushRemoteWrites(self):
        return self._flushRemoteWrites
    @flushRemoteWrites.setter
    def flushRemoteWrites(self, flushRemoteWrites not None : CUstreamMemOpFlushRemoteWritesParams_st):
        pass
        for _attr in dir(flushRemoteWrites):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._flushRemoteWrites, _attr, getattr(flushRemoteWrites, _attr))
    @property
    def pad(self):
        return self._pad
    @pad.setter
    def pad(self, pad):
        pass
        self._pad._ptr[0] = <ccuda.cuuint64_t> NULL if pad == None else (<cuuint64_t>pad)._ptr[0]

cdef class CUdevprop_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUdevprop_st *>calloc(1, sizeof(ccuda.CUdevprop_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUdevprop_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUdevprop_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['maxThreadsPerBlock : ' + str(self.maxThreadsPerBlock)]
            str_list += ['maxThreadsDim : ' + str(self.maxThreadsDim)]
            str_list += ['maxGridSize : ' + str(self.maxGridSize)]
            str_list += ['sharedMemPerBlock : ' + str(self.sharedMemPerBlock)]
            str_list += ['totalConstantMemory : ' + str(self.totalConstantMemory)]
            str_list += ['SIMDWidth : ' + str(self.SIMDWidth)]
            str_list += ['memPitch : ' + str(self.memPitch)]
            str_list += ['regsPerBlock : ' + str(self.regsPerBlock)]
            str_list += ['clockRate : ' + str(self.clockRate)]
            str_list += ['textureAlign : ' + str(self.textureAlign)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def maxThreadsPerBlock(self):
        return self._ptr[0].maxThreadsPerBlock
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int maxThreadsPerBlock):
        pass
        self._ptr[0].maxThreadsPerBlock = maxThreadsPerBlock
    @property
    def maxThreadsDim(self):
        return self._ptr[0].maxThreadsDim
    @maxThreadsDim.setter
    def maxThreadsDim(self, maxThreadsDim):
        pass
        self._ptr[0].maxThreadsDim = maxThreadsDim
    @property
    def maxGridSize(self):
        return self._ptr[0].maxGridSize
    @maxGridSize.setter
    def maxGridSize(self, maxGridSize):
        pass
        self._ptr[0].maxGridSize = maxGridSize
    @property
    def sharedMemPerBlock(self):
        return self._ptr[0].sharedMemPerBlock
    @sharedMemPerBlock.setter
    def sharedMemPerBlock(self, int sharedMemPerBlock):
        pass
        self._ptr[0].sharedMemPerBlock = sharedMemPerBlock
    @property
    def totalConstantMemory(self):
        return self._ptr[0].totalConstantMemory
    @totalConstantMemory.setter
    def totalConstantMemory(self, int totalConstantMemory):
        pass
        self._ptr[0].totalConstantMemory = totalConstantMemory
    @property
    def SIMDWidth(self):
        return self._ptr[0].SIMDWidth
    @SIMDWidth.setter
    def SIMDWidth(self, int SIMDWidth):
        pass
        self._ptr[0].SIMDWidth = SIMDWidth
    @property
    def memPitch(self):
        return self._ptr[0].memPitch
    @memPitch.setter
    def memPitch(self, int memPitch):
        pass
        self._ptr[0].memPitch = memPitch
    @property
    def regsPerBlock(self):
        return self._ptr[0].regsPerBlock
    @regsPerBlock.setter
    def regsPerBlock(self, int regsPerBlock):
        pass
        self._ptr[0].regsPerBlock = regsPerBlock
    @property
    def clockRate(self):
        return self._ptr[0].clockRate
    @clockRate.setter
    def clockRate(self, int clockRate):
        pass
        self._ptr[0].clockRate = clockRate
    @property
    def textureAlign(self):
        return self._ptr[0].textureAlign
    @textureAlign.setter
    def textureAlign(self, int textureAlign):
        pass
        self._ptr[0].textureAlign = textureAlign

cdef class CUaccessPolicyWindow_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUaccessPolicyWindow_st *>calloc(1, sizeof(ccuda.CUaccessPolicyWindow_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUaccessPolicyWindow_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUaccessPolicyWindow_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['base_ptr : ' + hex(self.base_ptr)]
            str_list += ['num_bytes : ' + str(self.num_bytes)]
            str_list += ['hitRatio : ' + str(self.hitRatio)]
            str_list += ['hitProp : ' + str(self.hitProp)]
            str_list += ['missProp : ' + str(self.missProp)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def base_ptr(self):
        return <void_ptr>self._ptr[0].base_ptr
    @base_ptr.setter
    def base_ptr(self, base_ptr):
        _cbase_ptr = utils.HelperInputVoidPtr(base_ptr)
        self._ptr[0].base_ptr = <void*><void_ptr>_cbase_ptr.cptr
    @property
    def num_bytes(self):
        return self._ptr[0].num_bytes
    @num_bytes.setter
    def num_bytes(self, size_t num_bytes):
        pass
        self._ptr[0].num_bytes = num_bytes
    @property
    def hitRatio(self):
        return self._ptr[0].hitRatio
    @hitRatio.setter
    def hitRatio(self, float hitRatio):
        pass
        self._ptr[0].hitRatio = hitRatio
    @property
    def hitProp(self):
        return CUaccessProperty(self._ptr[0].hitProp)
    @hitProp.setter
    def hitProp(self, hitProp not None : CUaccessProperty):
        pass
        self._ptr[0].hitProp = hitProp.value
    @property
    def missProp(self):
        return CUaccessProperty(self._ptr[0].missProp)
    @missProp.setter
    def missProp(self, missProp not None : CUaccessProperty):
        pass
        self._ptr[0].missProp = missProp.value

cdef class CUDA_KERNEL_NODE_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_KERNEL_NODE_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_KERNEL_NODE_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_KERNEL_NODE_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_KERNEL_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._func = CUfunction(_ptr=<void_ptr>&self._ptr[0].func)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['func : ' + str(self.func)]
            str_list += ['gridDimX : ' + str(self.gridDimX)]
            str_list += ['gridDimY : ' + str(self.gridDimY)]
            str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            str_list += ['blockDimX : ' + str(self.blockDimX)]
            str_list += ['blockDimY : ' + str(self.blockDimY)]
            str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            str_list += ['kernelParams : ' + str(self.kernelParams)]
            str_list += ['extra : ' + str(self.extra)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def func(self):
        return self._func
    @func.setter
    def func(self, func : CUfunction):
        pass
        self._func._ptr[0] = <ccuda.CUfunction> NULL if func == None else (<CUfunction>func)._ptr[0]
    @property
    def gridDimX(self):
        return self._ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        pass
        self._ptr[0].gridDimX = gridDimX
    @property
    def gridDimY(self):
        return self._ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        pass
        self._ptr[0].gridDimY = gridDimY
    @property
    def gridDimZ(self):
        return self._ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        pass
        self._ptr[0].gridDimZ = gridDimZ
    @property
    def blockDimX(self):
        return self._ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        pass
        self._ptr[0].blockDimX = blockDimX
    @property
    def blockDimY(self):
        return self._ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        pass
        self._ptr[0].blockDimY = blockDimY
    @property
    def blockDimZ(self):
        return self._ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        pass
        self._ptr[0].blockDimZ = blockDimZ
    @property
    def sharedMemBytes(self):
        return self._ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        pass
        self._ptr[0].sharedMemBytes = sharedMemBytes
    @property
    def kernelParams(self):
        return <void_ptr>self._ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._ckernelParams = utils.HelperKernelParams(kernelParams)
        self._ptr[0].kernelParams = <void**><void_ptr>self._ckernelParams.ckernelParams
    @property
    def extra(self):
        return <void_ptr>self._ptr[0].extra
    @extra.setter
    def extra(self, void_ptr extra):
        self._ptr[0].extra = <void**>extra

cdef class CUDA_MEMSET_NODE_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_MEMSET_NODE_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_MEMSET_NODE_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_MEMSET_NODE_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_MEMSET_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._dst = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dst)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['dst : ' + str(self.dst)]
            str_list += ['pitch : ' + str(self.pitch)]
            str_list += ['value : ' + str(self.value)]
            str_list += ['elementSize : ' + str(self.elementSize)]
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def dst(self):
        return self._dst
    @dst.setter
    def dst(self, dst : CUdeviceptr):
        pass
        self._dst._ptr[0] = <ccuda.CUdeviceptr> NULL if dst == None else (<CUdeviceptr>dst)._ptr[0]
    @property
    def pitch(self):
        return self._ptr[0].pitch
    @pitch.setter
    def pitch(self, size_t pitch):
        pass
        self._ptr[0].pitch = pitch
    @property
    def value(self):
        return self._ptr[0].value
    @value.setter
    def value(self, unsigned int value):
        pass
        self._ptr[0].value = value
    @property
    def elementSize(self):
        return self._ptr[0].elementSize
    @elementSize.setter
    def elementSize(self, unsigned int elementSize):
        pass
        self._ptr[0].elementSize = elementSize
    @property
    def width(self):
        return self._ptr[0].width
    @width.setter
    def width(self, size_t width):
        pass
        self._ptr[0].width = width
    @property
    def height(self):
        return self._ptr[0].height
    @height.setter
    def height(self, size_t height):
        pass
        self._ptr[0].height = height

cdef class CUDA_HOST_NODE_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_HOST_NODE_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_HOST_NODE_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_HOST_NODE_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_HOST_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._fn = CUhostFn(_ptr=<void_ptr>&self._ptr[0].fn)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fn : ' + str(self.fn)]
            str_list += ['userData : ' + hex(self.userData)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fn(self):
        return self._fn
    @fn.setter
    def fn(self, fn : CUhostFn):
        pass
        self._fn._ptr[0] = <ccuda.CUhostFn> NULL if fn == None else (<CUhostFn>fn)._ptr[0]
    @property
    def userData(self):
        return <void_ptr>self._ptr[0].userData
    @userData.setter
    def userData(self, userData):
        _cuserData = utils.HelperInputVoidPtr(userData)
        self._ptr[0].userData = <void*><void_ptr>_cuserData.cptr

cdef class CUkernelNodeAttrValue_union:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUkernelNodeAttrValue_union *>calloc(1, sizeof(ccuda.CUkernelNodeAttrValue_union))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUkernelNodeAttrValue_union)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUkernelNodeAttrValue_union *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._accessPolicyWindow = CUaccessPolicyWindow(_ptr=<void_ptr>&self._ptr[0].accessPolicyWindow)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['accessPolicyWindow :\n' + '\n'.join(['    ' + line for line in str(self.accessPolicyWindow).splitlines()])]
            str_list += ['cooperative : ' + str(self.cooperative)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def accessPolicyWindow(self):
        return self._accessPolicyWindow
    @accessPolicyWindow.setter
    def accessPolicyWindow(self, accessPolicyWindow not None : CUaccessPolicyWindow):
        pass
        for _attr in dir(accessPolicyWindow):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._accessPolicyWindow, _attr, getattr(accessPolicyWindow, _attr))
    @property
    def cooperative(self):
        return self._ptr[0].cooperative
    @cooperative.setter
    def cooperative(self, int cooperative):
        pass
        self._ptr[0].cooperative = cooperative

cdef class CUstreamAttrValue_union:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUstreamAttrValue_union *>calloc(1, sizeof(ccuda.CUstreamAttrValue_union))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUstreamAttrValue_union)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUstreamAttrValue_union *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._accessPolicyWindow = CUaccessPolicyWindow(_ptr=<void_ptr>&self._ptr[0].accessPolicyWindow)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['accessPolicyWindow :\n' + '\n'.join(['    ' + line for line in str(self.accessPolicyWindow).splitlines()])]
            str_list += ['syncPolicy : ' + str(self.syncPolicy)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def accessPolicyWindow(self):
        return self._accessPolicyWindow
    @accessPolicyWindow.setter
    def accessPolicyWindow(self, accessPolicyWindow not None : CUaccessPolicyWindow):
        pass
        for _attr in dir(accessPolicyWindow):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._accessPolicyWindow, _attr, getattr(accessPolicyWindow, _attr))
    @property
    def syncPolicy(self):
        return CUsynchronizationPolicy(self._ptr[0].syncPolicy)
    @syncPolicy.setter
    def syncPolicy(self, syncPolicy not None : CUsynchronizationPolicy):
        pass
        self._ptr[0].syncPolicy = syncPolicy.value

cdef class CUexecAffinitySmCount_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUexecAffinitySmCount_st *>calloc(1, sizeof(ccuda.CUexecAffinitySmCount_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUexecAffinitySmCount_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUexecAffinitySmCount_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['val : ' + str(self.val)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def val(self):
        return self._ptr[0].val
    @val.setter
    def val(self, unsigned int val):
        pass
        self._ptr[0].val = val

cdef class _CUexecAffinityParam_v1_CUexecAffinityParam_v1_CUexecAffinityParam_st_param_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUexecAffinityParam_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._smCount = CUexecAffinitySmCount(_ptr=<void_ptr>&self._ptr[0].param.smCount)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['smCount :\n' + '\n'.join(['    ' + line for line in str(self.smCount).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def smCount(self):
        return self._smCount
    @smCount.setter
    def smCount(self, smCount not None : CUexecAffinitySmCount):
        pass
        for _attr in dir(smCount):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._smCount, _attr, getattr(smCount, _attr))

cdef class CUexecAffinityParam_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUexecAffinityParam_st *>calloc(1, sizeof(ccuda.CUexecAffinityParam_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUexecAffinityParam_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUexecAffinityParam_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._param = _CUexecAffinityParam_v1_CUexecAffinityParam_v1_CUexecAffinityParam_st_param_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['param :\n' + '\n'.join(['    ' + line for line in str(self.param).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUexecAffinityType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUexecAffinityType):
        pass
        self._ptr[0].type = type.value
    @property
    def param(self):
        return self._param
    @param.setter
    def param(self, param not None : _CUexecAffinityParam_v1_CUexecAffinityParam_v1_CUexecAffinityParam_st_param_u):
        pass
        for _attr in dir(param):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._param, _attr, getattr(param, _attr))

cdef class CUDA_MEMCPY2D_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_MEMCPY2D_st *>calloc(1, sizeof(ccuda.CUDA_MEMCPY2D_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_MEMCPY2D_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_MEMCPY2D_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].srcDevice)
        self._srcArray = CUarray(_ptr=<void_ptr>&self._ptr[0].srcArray)
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dstDevice)
        self._dstArray = CUarray(_ptr=<void_ptr>&self._ptr[0].dstArray)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            str_list += ['srcY : ' + str(self.srcY)]
            str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            str_list += ['srcHost : ' + hex(self.srcHost)]
            str_list += ['srcDevice : ' + str(self.srcDevice)]
            str_list += ['srcArray : ' + str(self.srcArray)]
            str_list += ['srcPitch : ' + str(self.srcPitch)]
            str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            str_list += ['dstY : ' + str(self.dstY)]
            str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            str_list += ['dstHost : ' + hex(self.dstHost)]
            str_list += ['dstDevice : ' + str(self.dstDevice)]
            str_list += ['dstArray : ' + str(self.dstArray)]
            str_list += ['dstPitch : ' + str(self.dstPitch)]
            str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            str_list += ['Height : ' + str(self.Height)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def srcXInBytes(self):
        return self._ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        pass
        self._ptr[0].srcXInBytes = srcXInBytes
    @property
    def srcY(self):
        return self._ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        pass
        self._ptr[0].srcY = srcY
    @property
    def srcMemoryType(self):
        return CUmemorytype(self._ptr[0].srcMemoryType)
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].srcMemoryType = srcMemoryType.value
    @property
    def srcHost(self):
        return <void_ptr>self._ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = utils.HelperInputVoidPtr(srcHost)
        self._ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice : CUdeviceptr):
        pass
        self._srcDevice._ptr[0] = <ccuda.CUdeviceptr> NULL if srcDevice == None else (<CUdeviceptr>srcDevice)._ptr[0]
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray : CUarray):
        pass
        self._srcArray._ptr[0] = <ccuda.CUarray> NULL if srcArray == None else (<CUarray>srcArray)._ptr[0]
    @property
    def srcPitch(self):
        return self._ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        pass
        self._ptr[0].srcPitch = srcPitch
    @property
    def dstXInBytes(self):
        return self._ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        pass
        self._ptr[0].dstXInBytes = dstXInBytes
    @property
    def dstY(self):
        return self._ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        pass
        self._ptr[0].dstY = dstY
    @property
    def dstMemoryType(self):
        return CUmemorytype(self._ptr[0].dstMemoryType)
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].dstMemoryType = dstMemoryType.value
    @property
    def dstHost(self):
        return <void_ptr>self._ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = utils.HelperInputVoidPtr(dstHost)
        self._ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice : CUdeviceptr):
        pass
        self._dstDevice._ptr[0] = <ccuda.CUdeviceptr> NULL if dstDevice == None else (<CUdeviceptr>dstDevice)._ptr[0]
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray : CUarray):
        pass
        self._dstArray._ptr[0] = <ccuda.CUarray> NULL if dstArray == None else (<CUarray>dstArray)._ptr[0]
    @property
    def dstPitch(self):
        return self._ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        pass
        self._ptr[0].dstPitch = dstPitch
    @property
    def WidthInBytes(self):
        return self._ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        pass
        self._ptr[0].WidthInBytes = WidthInBytes
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height

cdef class CUDA_MEMCPY3D_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_MEMCPY3D_st *>calloc(1, sizeof(ccuda.CUDA_MEMCPY3D_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_MEMCPY3D_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_MEMCPY3D_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].srcDevice)
        self._srcArray = CUarray(_ptr=<void_ptr>&self._ptr[0].srcArray)
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dstDevice)
        self._dstArray = CUarray(_ptr=<void_ptr>&self._ptr[0].dstArray)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            str_list += ['srcY : ' + str(self.srcY)]
            str_list += ['srcZ : ' + str(self.srcZ)]
            str_list += ['srcLOD : ' + str(self.srcLOD)]
            str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            str_list += ['srcHost : ' + hex(self.srcHost)]
            str_list += ['srcDevice : ' + str(self.srcDevice)]
            str_list += ['srcArray : ' + str(self.srcArray)]
            str_list += ['reserved0 : ' + hex(self.reserved0)]
            str_list += ['srcPitch : ' + str(self.srcPitch)]
            str_list += ['srcHeight : ' + str(self.srcHeight)]
            str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            str_list += ['dstY : ' + str(self.dstY)]
            str_list += ['dstZ : ' + str(self.dstZ)]
            str_list += ['dstLOD : ' + str(self.dstLOD)]
            str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            str_list += ['dstHost : ' + hex(self.dstHost)]
            str_list += ['dstDevice : ' + str(self.dstDevice)]
            str_list += ['dstArray : ' + str(self.dstArray)]
            str_list += ['reserved1 : ' + hex(self.reserved1)]
            str_list += ['dstPitch : ' + str(self.dstPitch)]
            str_list += ['dstHeight : ' + str(self.dstHeight)]
            str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            str_list += ['Height : ' + str(self.Height)]
            str_list += ['Depth : ' + str(self.Depth)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def srcXInBytes(self):
        return self._ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        pass
        self._ptr[0].srcXInBytes = srcXInBytes
    @property
    def srcY(self):
        return self._ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        pass
        self._ptr[0].srcY = srcY
    @property
    def srcZ(self):
        return self._ptr[0].srcZ
    @srcZ.setter
    def srcZ(self, size_t srcZ):
        pass
        self._ptr[0].srcZ = srcZ
    @property
    def srcLOD(self):
        return self._ptr[0].srcLOD
    @srcLOD.setter
    def srcLOD(self, size_t srcLOD):
        pass
        self._ptr[0].srcLOD = srcLOD
    @property
    def srcMemoryType(self):
        return CUmemorytype(self._ptr[0].srcMemoryType)
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].srcMemoryType = srcMemoryType.value
    @property
    def srcHost(self):
        return <void_ptr>self._ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = utils.HelperInputVoidPtr(srcHost)
        self._ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice : CUdeviceptr):
        pass
        self._srcDevice._ptr[0] = <ccuda.CUdeviceptr> NULL if srcDevice == None else (<CUdeviceptr>srcDevice)._ptr[0]
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray : CUarray):
        pass
        self._srcArray._ptr[0] = <ccuda.CUarray> NULL if srcArray == None else (<CUarray>srcArray)._ptr[0]
    @property
    def reserved0(self):
        return <void_ptr>self._ptr[0].reserved0
    @reserved0.setter
    def reserved0(self, reserved0):
        _creserved0 = utils.HelperInputVoidPtr(reserved0)
        self._ptr[0].reserved0 = <void*><void_ptr>_creserved0.cptr
    @property
    def srcPitch(self):
        return self._ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        pass
        self._ptr[0].srcPitch = srcPitch
    @property
    def srcHeight(self):
        return self._ptr[0].srcHeight
    @srcHeight.setter
    def srcHeight(self, size_t srcHeight):
        pass
        self._ptr[0].srcHeight = srcHeight
    @property
    def dstXInBytes(self):
        return self._ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        pass
        self._ptr[0].dstXInBytes = dstXInBytes
    @property
    def dstY(self):
        return self._ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        pass
        self._ptr[0].dstY = dstY
    @property
    def dstZ(self):
        return self._ptr[0].dstZ
    @dstZ.setter
    def dstZ(self, size_t dstZ):
        pass
        self._ptr[0].dstZ = dstZ
    @property
    def dstLOD(self):
        return self._ptr[0].dstLOD
    @dstLOD.setter
    def dstLOD(self, size_t dstLOD):
        pass
        self._ptr[0].dstLOD = dstLOD
    @property
    def dstMemoryType(self):
        return CUmemorytype(self._ptr[0].dstMemoryType)
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].dstMemoryType = dstMemoryType.value
    @property
    def dstHost(self):
        return <void_ptr>self._ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = utils.HelperInputVoidPtr(dstHost)
        self._ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice : CUdeviceptr):
        pass
        self._dstDevice._ptr[0] = <ccuda.CUdeviceptr> NULL if dstDevice == None else (<CUdeviceptr>dstDevice)._ptr[0]
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray : CUarray):
        pass
        self._dstArray._ptr[0] = <ccuda.CUarray> NULL if dstArray == None else (<CUarray>dstArray)._ptr[0]
    @property
    def reserved1(self):
        return <void_ptr>self._ptr[0].reserved1
    @reserved1.setter
    def reserved1(self, reserved1):
        _creserved1 = utils.HelperInputVoidPtr(reserved1)
        self._ptr[0].reserved1 = <void*><void_ptr>_creserved1.cptr
    @property
    def dstPitch(self):
        return self._ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        pass
        self._ptr[0].dstPitch = dstPitch
    @property
    def dstHeight(self):
        return self._ptr[0].dstHeight
    @dstHeight.setter
    def dstHeight(self, size_t dstHeight):
        pass
        self._ptr[0].dstHeight = dstHeight
    @property
    def WidthInBytes(self):
        return self._ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        pass
        self._ptr[0].WidthInBytes = WidthInBytes
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height
    @property
    def Depth(self):
        return self._ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        pass
        self._ptr[0].Depth = Depth

cdef class CUDA_MEMCPY3D_PEER_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_MEMCPY3D_PEER_st *>calloc(1, sizeof(ccuda.CUDA_MEMCPY3D_PEER_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_MEMCPY3D_PEER_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_MEMCPY3D_PEER_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].srcDevice)
        self._srcArray = CUarray(_ptr=<void_ptr>&self._ptr[0].srcArray)
        self._srcContext = CUcontext(_ptr=<void_ptr>&self._ptr[0].srcContext)
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dstDevice)
        self._dstArray = CUarray(_ptr=<void_ptr>&self._ptr[0].dstArray)
        self._dstContext = CUcontext(_ptr=<void_ptr>&self._ptr[0].dstContext)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            str_list += ['srcY : ' + str(self.srcY)]
            str_list += ['srcZ : ' + str(self.srcZ)]
            str_list += ['srcLOD : ' + str(self.srcLOD)]
            str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            str_list += ['srcHost : ' + hex(self.srcHost)]
            str_list += ['srcDevice : ' + str(self.srcDevice)]
            str_list += ['srcArray : ' + str(self.srcArray)]
            str_list += ['srcContext : ' + str(self.srcContext)]
            str_list += ['srcPitch : ' + str(self.srcPitch)]
            str_list += ['srcHeight : ' + str(self.srcHeight)]
            str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            str_list += ['dstY : ' + str(self.dstY)]
            str_list += ['dstZ : ' + str(self.dstZ)]
            str_list += ['dstLOD : ' + str(self.dstLOD)]
            str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            str_list += ['dstHost : ' + hex(self.dstHost)]
            str_list += ['dstDevice : ' + str(self.dstDevice)]
            str_list += ['dstArray : ' + str(self.dstArray)]
            str_list += ['dstContext : ' + str(self.dstContext)]
            str_list += ['dstPitch : ' + str(self.dstPitch)]
            str_list += ['dstHeight : ' + str(self.dstHeight)]
            str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            str_list += ['Height : ' + str(self.Height)]
            str_list += ['Depth : ' + str(self.Depth)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def srcXInBytes(self):
        return self._ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        pass
        self._ptr[0].srcXInBytes = srcXInBytes
    @property
    def srcY(self):
        return self._ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        pass
        self._ptr[0].srcY = srcY
    @property
    def srcZ(self):
        return self._ptr[0].srcZ
    @srcZ.setter
    def srcZ(self, size_t srcZ):
        pass
        self._ptr[0].srcZ = srcZ
    @property
    def srcLOD(self):
        return self._ptr[0].srcLOD
    @srcLOD.setter
    def srcLOD(self, size_t srcLOD):
        pass
        self._ptr[0].srcLOD = srcLOD
    @property
    def srcMemoryType(self):
        return CUmemorytype(self._ptr[0].srcMemoryType)
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].srcMemoryType = srcMemoryType.value
    @property
    def srcHost(self):
        return <void_ptr>self._ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = utils.HelperInputVoidPtr(srcHost)
        self._ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice : CUdeviceptr):
        pass
        self._srcDevice._ptr[0] = <ccuda.CUdeviceptr> NULL if srcDevice == None else (<CUdeviceptr>srcDevice)._ptr[0]
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray : CUarray):
        pass
        self._srcArray._ptr[0] = <ccuda.CUarray> NULL if srcArray == None else (<CUarray>srcArray)._ptr[0]
    @property
    def srcContext(self):
        return self._srcContext
    @srcContext.setter
    def srcContext(self, srcContext : CUcontext):
        pass
        self._srcContext._ptr[0] = <ccuda.CUcontext> NULL if srcContext == None else (<CUcontext>srcContext)._ptr[0]
    @property
    def srcPitch(self):
        return self._ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        pass
        self._ptr[0].srcPitch = srcPitch
    @property
    def srcHeight(self):
        return self._ptr[0].srcHeight
    @srcHeight.setter
    def srcHeight(self, size_t srcHeight):
        pass
        self._ptr[0].srcHeight = srcHeight
    @property
    def dstXInBytes(self):
        return self._ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        pass
        self._ptr[0].dstXInBytes = dstXInBytes
    @property
    def dstY(self):
        return self._ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        pass
        self._ptr[0].dstY = dstY
    @property
    def dstZ(self):
        return self._ptr[0].dstZ
    @dstZ.setter
    def dstZ(self, size_t dstZ):
        pass
        self._ptr[0].dstZ = dstZ
    @property
    def dstLOD(self):
        return self._ptr[0].dstLOD
    @dstLOD.setter
    def dstLOD(self, size_t dstLOD):
        pass
        self._ptr[0].dstLOD = dstLOD
    @property
    def dstMemoryType(self):
        return CUmemorytype(self._ptr[0].dstMemoryType)
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].dstMemoryType = dstMemoryType.value
    @property
    def dstHost(self):
        return <void_ptr>self._ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = utils.HelperInputVoidPtr(dstHost)
        self._ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice : CUdeviceptr):
        pass
        self._dstDevice._ptr[0] = <ccuda.CUdeviceptr> NULL if dstDevice == None else (<CUdeviceptr>dstDevice)._ptr[0]
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray : CUarray):
        pass
        self._dstArray._ptr[0] = <ccuda.CUarray> NULL if dstArray == None else (<CUarray>dstArray)._ptr[0]
    @property
    def dstContext(self):
        return self._dstContext
    @dstContext.setter
    def dstContext(self, dstContext : CUcontext):
        pass
        self._dstContext._ptr[0] = <ccuda.CUcontext> NULL if dstContext == None else (<CUcontext>dstContext)._ptr[0]
    @property
    def dstPitch(self):
        return self._ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        pass
        self._ptr[0].dstPitch = dstPitch
    @property
    def dstHeight(self):
        return self._ptr[0].dstHeight
    @dstHeight.setter
    def dstHeight(self, size_t dstHeight):
        pass
        self._ptr[0].dstHeight = dstHeight
    @property
    def WidthInBytes(self):
        return self._ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        pass
        self._ptr[0].WidthInBytes = WidthInBytes
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height
    @property
    def Depth(self):
        return self._ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        pass
        self._ptr[0].Depth = Depth

cdef class CUDA_ARRAY_DESCRIPTOR_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_ARRAY_DESCRIPTOR_st *>calloc(1, sizeof(ccuda.CUDA_ARRAY_DESCRIPTOR_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_ARRAY_DESCRIPTOR_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_ARRAY_DESCRIPTOR_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['Width : ' + str(self.Width)]
            str_list += ['Height : ' + str(self.Height)]
            str_list += ['Format : ' + str(self.Format)]
            str_list += ['NumChannels : ' + str(self.NumChannels)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def Width(self):
        return self._ptr[0].Width
    @Width.setter
    def Width(self, size_t Width):
        pass
        self._ptr[0].Width = Width
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height
    @property
    def Format(self):
        return CUarray_format(self._ptr[0].Format)
    @Format.setter
    def Format(self, Format not None : CUarray_format):
        pass
        self._ptr[0].Format = Format.value
    @property
    def NumChannels(self):
        return self._ptr[0].NumChannels
    @NumChannels.setter
    def NumChannels(self, unsigned int NumChannels):
        pass
        self._ptr[0].NumChannels = NumChannels

cdef class CUDA_ARRAY3D_DESCRIPTOR_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_ARRAY3D_DESCRIPTOR_st *>calloc(1, sizeof(ccuda.CUDA_ARRAY3D_DESCRIPTOR_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_ARRAY3D_DESCRIPTOR_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_ARRAY3D_DESCRIPTOR_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['Width : ' + str(self.Width)]
            str_list += ['Height : ' + str(self.Height)]
            str_list += ['Depth : ' + str(self.Depth)]
            str_list += ['Format : ' + str(self.Format)]
            str_list += ['NumChannels : ' + str(self.NumChannels)]
            str_list += ['Flags : ' + str(self.Flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def Width(self):
        return self._ptr[0].Width
    @Width.setter
    def Width(self, size_t Width):
        pass
        self._ptr[0].Width = Width
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height
    @property
    def Depth(self):
        return self._ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        pass
        self._ptr[0].Depth = Depth
    @property
    def Format(self):
        return CUarray_format(self._ptr[0].Format)
    @Format.setter
    def Format(self, Format not None : CUarray_format):
        pass
        self._ptr[0].Format = Format.value
    @property
    def NumChannels(self):
        return self._ptr[0].NumChannels
    @NumChannels.setter
    def NumChannels(self, unsigned int NumChannels):
        pass
        self._ptr[0].NumChannels = NumChannels
    @property
    def Flags(self):
        return self._ptr[0].Flags
    @Flags.setter
    def Flags(self, unsigned int Flags):
        pass
        self._ptr[0].Flags = Flags

cdef class _CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_st_tileExtent_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            str_list += ['depth : ' + str(self.depth)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def width(self):
        return self._ptr[0].tileExtent.width
    @width.setter
    def width(self, unsigned int width):
        pass
        self._ptr[0].tileExtent.width = width
    @property
    def height(self):
        return self._ptr[0].tileExtent.height
    @height.setter
    def height(self, unsigned int height):
        pass
        self._ptr[0].tileExtent.height = height
    @property
    def depth(self):
        return self._ptr[0].tileExtent.depth
    @depth.setter
    def depth(self, unsigned int depth):
        pass
        self._ptr[0].tileExtent.depth = depth

cdef class CUDA_ARRAY_SPARSE_PROPERTIES_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st *>calloc(1, sizeof(ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._tileExtent = _CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_st_tileExtent_s(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['tileExtent :\n' + '\n'.join(['    ' + line for line in str(self.tileExtent).splitlines()])]
            str_list += ['miptailFirstLevel : ' + str(self.miptailFirstLevel)]
            str_list += ['miptailSize : ' + str(self.miptailSize)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def tileExtent(self):
        return self._tileExtent
    @tileExtent.setter
    def tileExtent(self, tileExtent not None : _CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_st_tileExtent_s):
        pass
        for _attr in dir(tileExtent):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._tileExtent, _attr, getattr(tileExtent, _attr))
    @property
    def miptailFirstLevel(self):
        return self._ptr[0].miptailFirstLevel
    @miptailFirstLevel.setter
    def miptailFirstLevel(self, unsigned int miptailFirstLevel):
        pass
        self._ptr[0].miptailFirstLevel = miptailFirstLevel
    @property
    def miptailSize(self):
        return self._ptr[0].miptailSize
    @miptailSize.setter
    def miptailSize(self, unsigned long long miptailSize):
        pass
        self._ptr[0].miptailSize = miptailSize
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_array_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._hArray = CUarray(_ptr=<void_ptr>&self._ptr[0].res.array.hArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['hArray : ' + str(self.hArray)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def hArray(self):
        return self._hArray
    @hArray.setter
    def hArray(self, hArray : CUarray):
        pass
        self._hArray._ptr[0] = <ccuda.CUarray> NULL if hArray == None else (<CUarray>hArray)._ptr[0]

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_mipmap_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._hMipmappedArray = CUmipmappedArray(_ptr=<void_ptr>&self._ptr[0].res.mipmap.hMipmappedArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['hMipmappedArray : ' + str(self.hMipmappedArray)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def hMipmappedArray(self):
        return self._hMipmappedArray
    @hMipmappedArray.setter
    def hMipmappedArray(self, hMipmappedArray : CUmipmappedArray):
        pass
        self._hMipmappedArray._ptr[0] = <ccuda.CUmipmappedArray> NULL if hMipmappedArray == None else (<CUmipmappedArray>hMipmappedArray)._ptr[0]

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_linear_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._devPtr = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].res.linear.devPtr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['devPtr : ' + str(self.devPtr)]
            str_list += ['format : ' + str(self.format)]
            str_list += ['numChannels : ' + str(self.numChannels)]
            str_list += ['sizeInBytes : ' + str(self.sizeInBytes)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def devPtr(self):
        return self._devPtr
    @devPtr.setter
    def devPtr(self, devPtr : CUdeviceptr):
        pass
        self._devPtr._ptr[0] = <ccuda.CUdeviceptr> NULL if devPtr == None else (<CUdeviceptr>devPtr)._ptr[0]
    @property
    def format(self):
        return CUarray_format(self._ptr[0].res.linear.format)
    @format.setter
    def format(self, format not None : CUarray_format):
        pass
        self._ptr[0].res.linear.format = format.value
    @property
    def numChannels(self):
        return self._ptr[0].res.linear.numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        pass
        self._ptr[0].res.linear.numChannels = numChannels
    @property
    def sizeInBytes(self):
        return self._ptr[0].res.linear.sizeInBytes
    @sizeInBytes.setter
    def sizeInBytes(self, size_t sizeInBytes):
        pass
        self._ptr[0].res.linear.sizeInBytes = sizeInBytes

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_pitch2D_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._devPtr = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].res.pitch2D.devPtr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['devPtr : ' + str(self.devPtr)]
            str_list += ['format : ' + str(self.format)]
            str_list += ['numChannels : ' + str(self.numChannels)]
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            str_list += ['pitchInBytes : ' + str(self.pitchInBytes)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def devPtr(self):
        return self._devPtr
    @devPtr.setter
    def devPtr(self, devPtr : CUdeviceptr):
        pass
        self._devPtr._ptr[0] = <ccuda.CUdeviceptr> NULL if devPtr == None else (<CUdeviceptr>devPtr)._ptr[0]
    @property
    def format(self):
        return CUarray_format(self._ptr[0].res.pitch2D.format)
    @format.setter
    def format(self, format not None : CUarray_format):
        pass
        self._ptr[0].res.pitch2D.format = format.value
    @property
    def numChannels(self):
        return self._ptr[0].res.pitch2D.numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        pass
        self._ptr[0].res.pitch2D.numChannels = numChannels
    @property
    def width(self):
        return self._ptr[0].res.pitch2D.width
    @width.setter
    def width(self, size_t width):
        pass
        self._ptr[0].res.pitch2D.width = width
    @property
    def height(self):
        return self._ptr[0].res.pitch2D.height
    @height.setter
    def height(self, size_t height):
        pass
        self._ptr[0].res.pitch2D.height = height
    @property
    def pitchInBytes(self):
        return self._ptr[0].res.pitch2D.pitchInBytes
    @pitchInBytes.setter
    def pitchInBytes(self, size_t pitchInBytes):
        pass
        self._ptr[0].res.pitch2D.pitchInBytes = pitchInBytes

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_reserved_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def reserved(self):
        return self._ptr[0].res.reserved.reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].res.reserved.reserved = reserved

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._array = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_array_s(_ptr=<void_ptr>self._ptr)
        self._mipmap = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_mipmap_s(_ptr=<void_ptr>self._ptr)
        self._linear = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_linear_s(_ptr=<void_ptr>self._ptr)
        self._pitch2D = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_pitch2D_s(_ptr=<void_ptr>self._ptr)
        self._reserved = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_reserved_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['array :\n' + '\n'.join(['    ' + line for line in str(self.array).splitlines()])]
            str_list += ['mipmap :\n' + '\n'.join(['    ' + line for line in str(self.mipmap).splitlines()])]
            str_list += ['linear :\n' + '\n'.join(['    ' + line for line in str(self.linear).splitlines()])]
            str_list += ['pitch2D :\n' + '\n'.join(['    ' + line for line in str(self.pitch2D).splitlines()])]
            str_list += ['reserved :\n' + '\n'.join(['    ' + line for line in str(self.reserved).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_array_s):
        pass
        for _attr in dir(array):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._array, _attr, getattr(array, _attr))
    @property
    def mipmap(self):
        return self._mipmap
    @mipmap.setter
    def mipmap(self, mipmap not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_mipmap_s):
        pass
        for _attr in dir(mipmap):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._mipmap, _attr, getattr(mipmap, _attr))
    @property
    def linear(self):
        return self._linear
    @linear.setter
    def linear(self, linear not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_linear_s):
        pass
        for _attr in dir(linear):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._linear, _attr, getattr(linear, _attr))
    @property
    def pitch2D(self):
        return self._pitch2D
    @pitch2D.setter
    def pitch2D(self, pitch2D not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_pitch2D_s):
        pass
        for _attr in dir(pitch2D):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._pitch2D, _attr, getattr(pitch2D, _attr))
    @property
    def reserved(self):
        return self._reserved
    @reserved.setter
    def reserved(self, reserved not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_reserved_s):
        pass
        for _attr in dir(reserved):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._reserved, _attr, getattr(reserved, _attr))

cdef class CUDA_RESOURCE_DESC_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>calloc(1, sizeof(ccuda.CUDA_RESOURCE_DESC_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_RESOURCE_DESC_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._res = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['resType : ' + str(self.resType)]
            str_list += ['res :\n' + '\n'.join(['    ' + line for line in str(self.res).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def resType(self):
        return CUresourcetype(self._ptr[0].resType)
    @resType.setter
    def resType(self, resType not None : CUresourcetype):
        pass
        self._ptr[0].resType = resType.value
    @property
    def res(self):
        return self._res
    @res.setter
    def res(self, res not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_u):
        pass
        for _attr in dir(res):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._res, _attr, getattr(res, _attr))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags

cdef class CUDA_TEXTURE_DESC_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_TEXTURE_DESC_st *>calloc(1, sizeof(ccuda.CUDA_TEXTURE_DESC_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_TEXTURE_DESC_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_TEXTURE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['addressMode : ' + str(self.addressMode)]
            str_list += ['filterMode : ' + str(self.filterMode)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['maxAnisotropy : ' + str(self.maxAnisotropy)]
            str_list += ['mipmapFilterMode : ' + str(self.mipmapFilterMode)]
            str_list += ['mipmapLevelBias : ' + str(self.mipmapLevelBias)]
            str_list += ['minMipmapLevelClamp : ' + str(self.minMipmapLevelClamp)]
            str_list += ['maxMipmapLevelClamp : ' + str(self.maxMipmapLevelClamp)]
            str_list += ['borderColor : ' + str(self.borderColor)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def addressMode(self):
        return [CUaddress_mode(_x) for _x in list(self._ptr[0].addressMode)]
    @addressMode.setter
    def addressMode(self, addressMode):
        self._ptr[0].addressMode = [_x.value for _x in addressMode]
    @property
    def filterMode(self):
        return CUfilter_mode(self._ptr[0].filterMode)
    @filterMode.setter
    def filterMode(self, filterMode not None : CUfilter_mode):
        pass
        self._ptr[0].filterMode = filterMode.value
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def maxAnisotropy(self):
        return self._ptr[0].maxAnisotropy
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int maxAnisotropy):
        pass
        self._ptr[0].maxAnisotropy = maxAnisotropy
    @property
    def mipmapFilterMode(self):
        return CUfilter_mode(self._ptr[0].mipmapFilterMode)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, mipmapFilterMode not None : CUfilter_mode):
        pass
        self._ptr[0].mipmapFilterMode = mipmapFilterMode.value
    @property
    def mipmapLevelBias(self):
        return self._ptr[0].mipmapLevelBias
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float mipmapLevelBias):
        pass
        self._ptr[0].mipmapLevelBias = mipmapLevelBias
    @property
    def minMipmapLevelClamp(self):
        return self._ptr[0].minMipmapLevelClamp
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float minMipmapLevelClamp):
        pass
        self._ptr[0].minMipmapLevelClamp = minMipmapLevelClamp
    @property
    def maxMipmapLevelClamp(self):
        return self._ptr[0].maxMipmapLevelClamp
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float maxMipmapLevelClamp):
        pass
        self._ptr[0].maxMipmapLevelClamp = maxMipmapLevelClamp
    @property
    def borderColor(self):
        return self._ptr[0].borderColor
    @borderColor.setter
    def borderColor(self, borderColor):
        pass
        self._ptr[0].borderColor = borderColor
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_RESOURCE_VIEW_DESC_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_RESOURCE_VIEW_DESC_st *>calloc(1, sizeof(ccuda.CUDA_RESOURCE_VIEW_DESC_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_RESOURCE_VIEW_DESC_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_RESOURCE_VIEW_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['format : ' + str(self.format)]
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            str_list += ['depth : ' + str(self.depth)]
            str_list += ['firstMipmapLevel : ' + str(self.firstMipmapLevel)]
            str_list += ['lastMipmapLevel : ' + str(self.lastMipmapLevel)]
            str_list += ['firstLayer : ' + str(self.firstLayer)]
            str_list += ['lastLayer : ' + str(self.lastLayer)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def format(self):
        return CUresourceViewFormat(self._ptr[0].format)
    @format.setter
    def format(self, format not None : CUresourceViewFormat):
        pass
        self._ptr[0].format = format.value
    @property
    def width(self):
        return self._ptr[0].width
    @width.setter
    def width(self, size_t width):
        pass
        self._ptr[0].width = width
    @property
    def height(self):
        return self._ptr[0].height
    @height.setter
    def height(self, size_t height):
        pass
        self._ptr[0].height = height
    @property
    def depth(self):
        return self._ptr[0].depth
    @depth.setter
    def depth(self, size_t depth):
        pass
        self._ptr[0].depth = depth
    @property
    def firstMipmapLevel(self):
        return self._ptr[0].firstMipmapLevel
    @firstMipmapLevel.setter
    def firstMipmapLevel(self, unsigned int firstMipmapLevel):
        pass
        self._ptr[0].firstMipmapLevel = firstMipmapLevel
    @property
    def lastMipmapLevel(self):
        return self._ptr[0].lastMipmapLevel
    @lastMipmapLevel.setter
    def lastMipmapLevel(self, unsigned int lastMipmapLevel):
        pass
        self._ptr[0].lastMipmapLevel = lastMipmapLevel
    @property
    def firstLayer(self):
        return self._ptr[0].firstLayer
    @firstLayer.setter
    def firstLayer(self, unsigned int firstLayer):
        pass
        self._ptr[0].firstLayer = firstLayer
    @property
    def lastLayer(self):
        return self._ptr[0].lastLayer
    @lastLayer.setter
    def lastLayer(self, unsigned int lastLayer):
        pass
        self._ptr[0].lastLayer = lastLayer
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st *>calloc(1, sizeof(ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['p2pToken : ' + str(self.p2pToken)]
            str_list += ['vaSpaceToken : ' + str(self.vaSpaceToken)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def p2pToken(self):
        return self._ptr[0].p2pToken
    @p2pToken.setter
    def p2pToken(self, unsigned long long p2pToken):
        pass
        self._ptr[0].p2pToken = p2pToken
    @property
    def vaSpaceToken(self):
        return self._ptr[0].vaSpaceToken
    @vaSpaceToken.setter
    def vaSpaceToken(self, unsigned int vaSpaceToken):
        pass
        self._ptr[0].vaSpaceToken = vaSpaceToken

cdef class CUDA_LAUNCH_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_LAUNCH_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_LAUNCH_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_LAUNCH_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_LAUNCH_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._function = CUfunction(_ptr=<void_ptr>&self._ptr[0].function)
        self._hStream = CUstream(_ptr=<void_ptr>&self._ptr[0].hStream)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['function : ' + str(self.function)]
            str_list += ['gridDimX : ' + str(self.gridDimX)]
            str_list += ['gridDimY : ' + str(self.gridDimY)]
            str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            str_list += ['blockDimX : ' + str(self.blockDimX)]
            str_list += ['blockDimY : ' + str(self.blockDimY)]
            str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            str_list += ['hStream : ' + str(self.hStream)]
            str_list += ['kernelParams : ' + str(self.kernelParams)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def function(self):
        return self._function
    @function.setter
    def function(self, function : CUfunction):
        pass
        self._function._ptr[0] = <ccuda.CUfunction> NULL if function == None else (<CUfunction>function)._ptr[0]
    @property
    def gridDimX(self):
        return self._ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        pass
        self._ptr[0].gridDimX = gridDimX
    @property
    def gridDimY(self):
        return self._ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        pass
        self._ptr[0].gridDimY = gridDimY
    @property
    def gridDimZ(self):
        return self._ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        pass
        self._ptr[0].gridDimZ = gridDimZ
    @property
    def blockDimX(self):
        return self._ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        pass
        self._ptr[0].blockDimX = blockDimX
    @property
    def blockDimY(self):
        return self._ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        pass
        self._ptr[0].blockDimY = blockDimY
    @property
    def blockDimZ(self):
        return self._ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        pass
        self._ptr[0].blockDimZ = blockDimZ
    @property
    def sharedMemBytes(self):
        return self._ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        pass
        self._ptr[0].sharedMemBytes = sharedMemBytes
    @property
    def hStream(self):
        return self._hStream
    @hStream.setter
    def hStream(self, hStream : CUstream):
        pass
        self._hStream._ptr[0] = <ccuda.CUstream> NULL if hStream == None else (<CUstream>hStream)._ptr[0]
    @property
    def kernelParams(self):
        return <void_ptr>self._ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._ckernelParams = utils.HelperKernelParams(kernelParams)
        self._ptr[0].kernelParams = <void**><void_ptr>self._ckernelParams.ckernelParams

cdef class _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_handle_win32_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['handle : ' + hex(self.handle)]
            str_list += ['name : ' + hex(self.name)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def handle(self):
        return <void_ptr>self._ptr[0].handle.win32.handle
    @handle.setter
    def handle(self, handle):
        _chandle = utils.HelperInputVoidPtr(handle)
        self._ptr[0].handle.win32.handle = <void*><void_ptr>_chandle.cptr
    @property
    def name(self):
        return <void_ptr>self._ptr[0].handle.win32.name
    @name.setter
    def name(self, name):
        _cname = utils.HelperInputVoidPtr(name)
        self._ptr[0].handle.win32.name = <void*><void_ptr>_cname.cptr

cdef class _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._win32 = _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_handle_win32_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fd : ' + str(self.fd)]
            str_list += ['win32 :\n' + '\n'.join(['    ' + line for line in str(self.win32).splitlines()])]
            str_list += ['nvSciBufObject : ' + hex(self.nvSciBufObject)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fd(self):
        return self._ptr[0].handle.fd
    @fd.setter
    def fd(self, int fd):
        pass
        self._ptr[0].handle.fd = fd
    @property
    def win32(self):
        return self._win32
    @win32.setter
    def win32(self, win32 not None : _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_handle_win32_s):
        pass
        for _attr in dir(win32):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._win32, _attr, getattr(win32, _attr))
    @property
    def nvSciBufObject(self):
        return <void_ptr>self._ptr[0].handle.nvSciBufObject
    @nvSciBufObject.setter
    def nvSciBufObject(self, nvSciBufObject):
        _cnvSciBufObject = utils.HelperInputVoidPtr(nvSciBufObject)
        self._ptr[0].handle.nvSciBufObject = <void*><void_ptr>_cnvSciBufObject.cptr

cdef class CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>calloc(1, sizeof(ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._handle = _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['handle :\n' + '\n'.join(['    ' + line for line in str(self.handle).splitlines()])]
            str_list += ['size : ' + str(self.size)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUexternalMemoryHandleType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUexternalMemoryHandleType):
        pass
        self._ptr[0].type = type.value
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle not None : _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_u):
        pass
        for _attr in dir(handle):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._handle, _attr, getattr(handle, _attr))
    @property
    def size(self):
        return self._ptr[0].size
    @size.setter
    def size(self, unsigned long long size):
        pass
        self._ptr[0].size = size
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st *>calloc(1, sizeof(ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['offset : ' + str(self.offset)]
            str_list += ['size : ' + str(self.size)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def offset(self):
        return self._ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        pass
        self._ptr[0].offset = offset
    @property
    def size(self):
        return self._ptr[0].size
    @size.setter
    def size(self, unsigned long long size):
        pass
        self._ptr[0].size = size
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st *>calloc(1, sizeof(ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._arrayDesc = CUDA_ARRAY3D_DESCRIPTOR(_ptr=<void_ptr>&self._ptr[0].arrayDesc)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['offset : ' + str(self.offset)]
            str_list += ['arrayDesc :\n' + '\n'.join(['    ' + line for line in str(self.arrayDesc).splitlines()])]
            str_list += ['numLevels : ' + str(self.numLevels)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def offset(self):
        return self._ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        pass
        self._ptr[0].offset = offset
    @property
    def arrayDesc(self):
        return self._arrayDesc
    @arrayDesc.setter
    def arrayDesc(self, arrayDesc not None : CUDA_ARRAY3D_DESCRIPTOR):
        pass
        for _attr in dir(arrayDesc):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._arrayDesc, _attr, getattr(arrayDesc, _attr))
    @property
    def numLevels(self):
        return self._ptr[0].numLevels
    @numLevels.setter
    def numLevels(self, unsigned int numLevels):
        pass
        self._ptr[0].numLevels = numLevels
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_handle_win32_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['handle : ' + hex(self.handle)]
            str_list += ['name : ' + hex(self.name)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def handle(self):
        return <void_ptr>self._ptr[0].handle.win32.handle
    @handle.setter
    def handle(self, handle):
        _chandle = utils.HelperInputVoidPtr(handle)
        self._ptr[0].handle.win32.handle = <void*><void_ptr>_chandle.cptr
    @property
    def name(self):
        return <void_ptr>self._ptr[0].handle.win32.name
    @name.setter
    def name(self, name):
        _cname = utils.HelperInputVoidPtr(name)
        self._ptr[0].handle.win32.name = <void*><void_ptr>_cname.cptr

cdef class _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._win32 = _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_handle_win32_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fd : ' + str(self.fd)]
            str_list += ['win32 :\n' + '\n'.join(['    ' + line for line in str(self.win32).splitlines()])]
            str_list += ['nvSciSyncObj : ' + hex(self.nvSciSyncObj)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fd(self):
        return self._ptr[0].handle.fd
    @fd.setter
    def fd(self, int fd):
        pass
        self._ptr[0].handle.fd = fd
    @property
    def win32(self):
        return self._win32
    @win32.setter
    def win32(self, win32 not None : _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_handle_win32_s):
        pass
        for _attr in dir(win32):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._win32, _attr, getattr(win32, _attr))
    @property
    def nvSciSyncObj(self):
        return <void_ptr>self._ptr[0].handle.nvSciSyncObj
    @nvSciSyncObj.setter
    def nvSciSyncObj(self, nvSciSyncObj):
        _cnvSciSyncObj = utils.HelperInputVoidPtr(nvSciSyncObj)
        self._ptr[0].handle.nvSciSyncObj = <void*><void_ptr>_cnvSciSyncObj.cptr

cdef class CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>calloc(1, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._handle = _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['handle :\n' + '\n'.join(['    ' + line for line in str(self.handle).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUexternalSemaphoreHandleType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUexternalSemaphoreHandleType):
        pass
        self._ptr[0].type = type.value
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle not None : _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_u):
        pass
        for _attr in dir(handle):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._handle, _attr, getattr(handle, _attr))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_fence_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['value : ' + str(self.value)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def value(self):
        return self._ptr[0].params.fence.value
    @value.setter
    def value(self, unsigned long long value):
        pass
        self._ptr[0].params.fence.value = value

cdef class _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_nvSciSync_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fence : ' + hex(self.fence)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fence(self):
        return <void_ptr>self._ptr[0].params.nvSciSync.fence
    @fence.setter
    def fence(self, fence):
        _cfence = utils.HelperInputVoidPtr(fence)
        self._ptr[0].params.nvSciSync.fence = <void*><void_ptr>_cfence.cptr
    @property
    def reserved(self):
        return self._ptr[0].params.nvSciSync.reserved
    @reserved.setter
    def reserved(self, unsigned long long reserved):
        pass
        self._ptr[0].params.nvSciSync.reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_keyedMutex_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['key : ' + str(self.key)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def key(self):
        return self._ptr[0].params.keyedMutex.key
    @key.setter
    def key(self, unsigned long long key):
        pass
        self._ptr[0].params.keyedMutex.key = key

cdef class _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._fence = _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_fence_s(_ptr=<void_ptr>self._ptr)
        self._nvSciSync = _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_nvSciSync_u(_ptr=<void_ptr>self._ptr)
        self._keyedMutex = _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_keyedMutex_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fence :\n' + '\n'.join(['    ' + line for line in str(self.fence).splitlines()])]
            str_list += ['nvSciSync :\n' + '\n'.join(['    ' + line for line in str(self.nvSciSync).splitlines()])]
            str_list += ['keyedMutex :\n' + '\n'.join(['    ' + line for line in str(self.keyedMutex).splitlines()])]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fence(self):
        return self._fence
    @fence.setter
    def fence(self, fence not None : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_fence_s):
        pass
        for _attr in dir(fence):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._fence, _attr, getattr(fence, _attr))
    @property
    def nvSciSync(self):
        return self._nvSciSync
    @nvSciSync.setter
    def nvSciSync(self, nvSciSync not None : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_nvSciSync_u):
        pass
        for _attr in dir(nvSciSync):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._nvSciSync, _attr, getattr(nvSciSync, _attr))
    @property
    def keyedMutex(self):
        return self._keyedMutex
    @keyedMutex.setter
    def keyedMutex(self, keyedMutex not None : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_keyedMutex_s):
        pass
        for _attr in dir(keyedMutex):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._keyedMutex, _attr, getattr(keyedMutex, _attr))
    @property
    def reserved(self):
        return self._ptr[0].params.reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].params.reserved = reserved

cdef class CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._params = _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_s(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['params :\n' + '\n'.join(['    ' + line for line in str(self.params).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def params(self):
        return self._params
    @params.setter
    def params(self, params not None : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_s):
        pass
        for _attr in dir(params):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._params, _attr, getattr(params, _attr))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_fence_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['value : ' + str(self.value)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def value(self):
        return self._ptr[0].params.fence.value
    @value.setter
    def value(self, unsigned long long value):
        pass
        self._ptr[0].params.fence.value = value

cdef class _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_nvSciSync_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fence : ' + hex(self.fence)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fence(self):
        return <void_ptr>self._ptr[0].params.nvSciSync.fence
    @fence.setter
    def fence(self, fence):
        _cfence = utils.HelperInputVoidPtr(fence)
        self._ptr[0].params.nvSciSync.fence = <void*><void_ptr>_cfence.cptr
    @property
    def reserved(self):
        return self._ptr[0].params.nvSciSync.reserved
    @reserved.setter
    def reserved(self, unsigned long long reserved):
        pass
        self._ptr[0].params.nvSciSync.reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_keyedMutex_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['key : ' + str(self.key)]
            str_list += ['timeoutMs : ' + str(self.timeoutMs)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def key(self):
        return self._ptr[0].params.keyedMutex.key
    @key.setter
    def key(self, unsigned long long key):
        pass
        self._ptr[0].params.keyedMutex.key = key
    @property
    def timeoutMs(self):
        return self._ptr[0].params.keyedMutex.timeoutMs
    @timeoutMs.setter
    def timeoutMs(self, unsigned int timeoutMs):
        pass
        self._ptr[0].params.keyedMutex.timeoutMs = timeoutMs

cdef class _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._fence = _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_fence_s(_ptr=<void_ptr>self._ptr)
        self._nvSciSync = _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_nvSciSync_u(_ptr=<void_ptr>self._ptr)
        self._keyedMutex = _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_keyedMutex_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fence :\n' + '\n'.join(['    ' + line for line in str(self.fence).splitlines()])]
            str_list += ['nvSciSync :\n' + '\n'.join(['    ' + line for line in str(self.nvSciSync).splitlines()])]
            str_list += ['keyedMutex :\n' + '\n'.join(['    ' + line for line in str(self.keyedMutex).splitlines()])]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fence(self):
        return self._fence
    @fence.setter
    def fence(self, fence not None : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_fence_s):
        pass
        for _attr in dir(fence):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._fence, _attr, getattr(fence, _attr))
    @property
    def nvSciSync(self):
        return self._nvSciSync
    @nvSciSync.setter
    def nvSciSync(self, nvSciSync not None : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_nvSciSync_u):
        pass
        for _attr in dir(nvSciSync):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._nvSciSync, _attr, getattr(nvSciSync, _attr))
    @property
    def keyedMutex(self):
        return self._keyedMutex
    @keyedMutex.setter
    def keyedMutex(self, keyedMutex not None : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_keyedMutex_s):
        pass
        for _attr in dir(keyedMutex):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._keyedMutex, _attr, getattr(keyedMutex, _attr))
    @property
    def reserved(self):
        return self._ptr[0].params.reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].params.reserved = reserved

cdef class CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._params = _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_s(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['params :\n' + '\n'.join(['    ' + line for line in str(self.params).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def params(self):
        return self._params
    @params.setter
    def params(self, params not None : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_s):
        pass
        for _attr in dir(params):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._params, _attr, getattr(params, _attr))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        if self._paramsArray is not NULL:
            free(self._paramsArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['extSemArray : ' + str(self.extSemArray)]
            str_list += ['paramsArray : ' + str(self.paramsArray)]
            str_list += ['numExtSems : ' + str(self.numExtSems)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._ptr[0].extSemArray + x*sizeof(ccuda.CUexternalSemaphore) for x in range(self._extSemArray_length)]
        return [CUexternalSemaphore(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <ccuda.CUexternalSemaphore*> calloc(len(val), sizeof(ccuda.CUexternalSemaphore))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUexternalSemaphore)))
                self._extSemArray_length = <size_t>len(val)
                self._ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<CUexternalSemaphore>val[idx])._ptr[0]
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._ptr[0].paramsArray + x*sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS) for x in range(self._paramsArray_length)]
        return [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS*> calloc(len(val), sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)))
                self._paramsArray_length = <size_t>len(val)
                self._ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                memcpy(&self._paramsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>val[idx])._ptr, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
    @property
    def numExtSems(self):
        return self._ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        pass
        self._ptr[0].numExtSems = numExtSems

cdef class CUDA_EXT_SEM_WAIT_NODE_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        if self._paramsArray is not NULL:
            free(self._paramsArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['extSemArray : ' + str(self.extSemArray)]
            str_list += ['paramsArray : ' + str(self.paramsArray)]
            str_list += ['numExtSems : ' + str(self.numExtSems)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._ptr[0].extSemArray + x*sizeof(ccuda.CUexternalSemaphore) for x in range(self._extSemArray_length)]
        return [CUexternalSemaphore(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <ccuda.CUexternalSemaphore*> calloc(len(val), sizeof(ccuda.CUexternalSemaphore))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUexternalSemaphore)))
                self._extSemArray_length = <size_t>len(val)
                self._ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<CUexternalSemaphore>val[idx])._ptr[0]
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._ptr[0].paramsArray + x*sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS) for x in range(self._paramsArray_length)]
        return [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS*> calloc(len(val), sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)))
                self._paramsArray_length = <size_t>len(val)
                self._ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                memcpy(&self._paramsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>val[idx])._ptr, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
    @property
    def numExtSems(self):
        return self._ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        pass
        self._ptr[0].numExtSems = numExtSems

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_resource_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._mipmap = CUmipmappedArray(_ptr=<void_ptr>&self._ptr[0].resource.mipmap)
        self._array = CUarray(_ptr=<void_ptr>&self._ptr[0].resource.array)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['mipmap : ' + str(self.mipmap)]
            str_list += ['array : ' + str(self.array)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def mipmap(self):
        return self._mipmap
    @mipmap.setter
    def mipmap(self, mipmap : CUmipmappedArray):
        pass
        self._mipmap._ptr[0] = <ccuda.CUmipmappedArray> NULL if mipmap == None else (<CUmipmappedArray>mipmap)._ptr[0]
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array : CUarray):
        pass
        self._array._ptr[0] = <ccuda.CUarray> NULL if array == None else (<CUarray>array)._ptr[0]

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_sparseLevel_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['level : ' + str(self.level)]
            str_list += ['layer : ' + str(self.layer)]
            str_list += ['offsetX : ' + str(self.offsetX)]
            str_list += ['offsetY : ' + str(self.offsetY)]
            str_list += ['offsetZ : ' + str(self.offsetZ)]
            str_list += ['extentWidth : ' + str(self.extentWidth)]
            str_list += ['extentHeight : ' + str(self.extentHeight)]
            str_list += ['extentDepth : ' + str(self.extentDepth)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def level(self):
        return self._ptr[0].subresource.sparseLevel.level
    @level.setter
    def level(self, unsigned int level):
        pass
        self._ptr[0].subresource.sparseLevel.level = level
    @property
    def layer(self):
        return self._ptr[0].subresource.sparseLevel.layer
    @layer.setter
    def layer(self, unsigned int layer):
        pass
        self._ptr[0].subresource.sparseLevel.layer = layer
    @property
    def offsetX(self):
        return self._ptr[0].subresource.sparseLevel.offsetX
    @offsetX.setter
    def offsetX(self, unsigned int offsetX):
        pass
        self._ptr[0].subresource.sparseLevel.offsetX = offsetX
    @property
    def offsetY(self):
        return self._ptr[0].subresource.sparseLevel.offsetY
    @offsetY.setter
    def offsetY(self, unsigned int offsetY):
        pass
        self._ptr[0].subresource.sparseLevel.offsetY = offsetY
    @property
    def offsetZ(self):
        return self._ptr[0].subresource.sparseLevel.offsetZ
    @offsetZ.setter
    def offsetZ(self, unsigned int offsetZ):
        pass
        self._ptr[0].subresource.sparseLevel.offsetZ = offsetZ
    @property
    def extentWidth(self):
        return self._ptr[0].subresource.sparseLevel.extentWidth
    @extentWidth.setter
    def extentWidth(self, unsigned int extentWidth):
        pass
        self._ptr[0].subresource.sparseLevel.extentWidth = extentWidth
    @property
    def extentHeight(self):
        return self._ptr[0].subresource.sparseLevel.extentHeight
    @extentHeight.setter
    def extentHeight(self, unsigned int extentHeight):
        pass
        self._ptr[0].subresource.sparseLevel.extentHeight = extentHeight
    @property
    def extentDepth(self):
        return self._ptr[0].subresource.sparseLevel.extentDepth
    @extentDepth.setter
    def extentDepth(self, unsigned int extentDepth):
        pass
        self._ptr[0].subresource.sparseLevel.extentDepth = extentDepth

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_miptail_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['layer : ' + str(self.layer)]
            str_list += ['offset : ' + str(self.offset)]
            str_list += ['size : ' + str(self.size)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def layer(self):
        return self._ptr[0].subresource.miptail.layer
    @layer.setter
    def layer(self, unsigned int layer):
        pass
        self._ptr[0].subresource.miptail.layer = layer
    @property
    def offset(self):
        return self._ptr[0].subresource.miptail.offset
    @offset.setter
    def offset(self, unsigned long long offset):
        pass
        self._ptr[0].subresource.miptail.offset = offset
    @property
    def size(self):
        return self._ptr[0].subresource.miptail.size
    @size.setter
    def size(self, unsigned long long size):
        pass
        self._ptr[0].subresource.miptail.size = size

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._sparseLevel = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_sparseLevel_s(_ptr=<void_ptr>self._ptr)
        self._miptail = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_miptail_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['sparseLevel :\n' + '\n'.join(['    ' + line for line in str(self.sparseLevel).splitlines()])]
            str_list += ['miptail :\n' + '\n'.join(['    ' + line for line in str(self.miptail).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def sparseLevel(self):
        return self._sparseLevel
    @sparseLevel.setter
    def sparseLevel(self, sparseLevel not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_sparseLevel_s):
        pass
        for _attr in dir(sparseLevel):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._sparseLevel, _attr, getattr(sparseLevel, _attr))
    @property
    def miptail(self):
        return self._miptail
    @miptail.setter
    def miptail(self, miptail not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_miptail_s):
        pass
        for _attr in dir(miptail):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._miptail, _attr, getattr(miptail, _attr))

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_memHandle_u:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._memHandle = CUmemGenericAllocationHandle(_ptr=<void_ptr>&self._ptr[0].memHandle.memHandle)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['memHandle : ' + str(self.memHandle)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def memHandle(self):
        return self._memHandle
    @memHandle.setter
    def memHandle(self, memHandle : CUmemGenericAllocationHandle):
        pass
        self._memHandle._ptr[0] = <ccuda.CUmemGenericAllocationHandle> NULL if memHandle == None else (<CUmemGenericAllocationHandle>memHandle)._ptr[0]

cdef class CUarrayMapInfo_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUarrayMapInfo_st *>calloc(1, sizeof(ccuda.CUarrayMapInfo_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUarrayMapInfo_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._resource = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_resource_u(_ptr=<void_ptr>self._ptr)
        self._subresource = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_u(_ptr=<void_ptr>self._ptr)
        self._memHandle = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_memHandle_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['resourceType : ' + str(self.resourceType)]
            str_list += ['resource :\n' + '\n'.join(['    ' + line for line in str(self.resource).splitlines()])]
            str_list += ['subresourceType : ' + str(self.subresourceType)]
            str_list += ['subresource :\n' + '\n'.join(['    ' + line for line in str(self.subresource).splitlines()])]
            str_list += ['memOperationType : ' + str(self.memOperationType)]
            str_list += ['memHandleType : ' + str(self.memHandleType)]
            str_list += ['memHandle :\n' + '\n'.join(['    ' + line for line in str(self.memHandle).splitlines()])]
            str_list += ['offset : ' + str(self.offset)]
            str_list += ['deviceBitMask : ' + str(self.deviceBitMask)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def resourceType(self):
        return CUresourcetype(self._ptr[0].resourceType)
    @resourceType.setter
    def resourceType(self, resourceType not None : CUresourcetype):
        pass
        self._ptr[0].resourceType = resourceType.value
    @property
    def resource(self):
        return self._resource
    @resource.setter
    def resource(self, resource not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_resource_u):
        pass
        for _attr in dir(resource):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._resource, _attr, getattr(resource, _attr))
    @property
    def subresourceType(self):
        return CUarraySparseSubresourceType(self._ptr[0].subresourceType)
    @subresourceType.setter
    def subresourceType(self, subresourceType not None : CUarraySparseSubresourceType):
        pass
        self._ptr[0].subresourceType = subresourceType.value
    @property
    def subresource(self):
        return self._subresource
    @subresource.setter
    def subresource(self, subresource not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_u):
        pass
        for _attr in dir(subresource):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._subresource, _attr, getattr(subresource, _attr))
    @property
    def memOperationType(self):
        return CUmemOperationType(self._ptr[0].memOperationType)
    @memOperationType.setter
    def memOperationType(self, memOperationType not None : CUmemOperationType):
        pass
        self._ptr[0].memOperationType = memOperationType.value
    @property
    def memHandleType(self):
        return CUmemHandleType(self._ptr[0].memHandleType)
    @memHandleType.setter
    def memHandleType(self, memHandleType not None : CUmemHandleType):
        pass
        self._ptr[0].memHandleType = memHandleType.value
    @property
    def memHandle(self):
        return self._memHandle
    @memHandle.setter
    def memHandle(self, memHandle not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_memHandle_u):
        pass
        for _attr in dir(memHandle):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._memHandle, _attr, getattr(memHandle, _attr))
    @property
    def offset(self):
        return self._ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        pass
        self._ptr[0].offset = offset
    @property
    def deviceBitMask(self):
        return self._ptr[0].deviceBitMask
    @deviceBitMask.setter
    def deviceBitMask(self, unsigned int deviceBitMask):
        pass
        self._ptr[0].deviceBitMask = deviceBitMask
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUmemLocation_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmemLocation_st *>calloc(1, sizeof(ccuda.CUmemLocation_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmemLocation_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmemLocation_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['id : ' + str(self.id)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUmemLocationType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUmemLocationType):
        pass
        self._ptr[0].type = type.value
    @property
    def id(self):
        return self._ptr[0].id
    @id.setter
    def id(self, int id):
        pass
        self._ptr[0].id = id

cdef class _CUmemAllocationProp_v1_CUmemAllocationProp_v1_CUmemAllocationProp_st_allocFlags_s:
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUmemAllocationProp_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['compressionType : ' + str(self.compressionType)]
            str_list += ['gpuDirectRDMACapable : ' + str(self.gpuDirectRDMACapable)]
            str_list += ['usage : ' + str(self.usage)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def compressionType(self):
        return self._ptr[0].allocFlags.compressionType
    @compressionType.setter
    def compressionType(self, unsigned char compressionType):
        pass
        self._ptr[0].allocFlags.compressionType = compressionType
    @property
    def gpuDirectRDMACapable(self):
        return self._ptr[0].allocFlags.gpuDirectRDMACapable
    @gpuDirectRDMACapable.setter
    def gpuDirectRDMACapable(self, unsigned char gpuDirectRDMACapable):
        pass
        self._ptr[0].allocFlags.gpuDirectRDMACapable = gpuDirectRDMACapable
    @property
    def usage(self):
        return self._ptr[0].allocFlags.usage
    @usage.setter
    def usage(self, unsigned short usage):
        pass
        self._ptr[0].allocFlags.usage = usage
    @property
    def reserved(self):
        return self._ptr[0].allocFlags.reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].allocFlags.reserved = reserved

cdef class CUmemAllocationProp_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmemAllocationProp_st *>calloc(1, sizeof(ccuda.CUmemAllocationProp_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmemAllocationProp_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmemAllocationProp_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._location = CUmemLocation(_ptr=<void_ptr>&self._ptr[0].location)
        self._allocFlags = _CUmemAllocationProp_v1_CUmemAllocationProp_v1_CUmemAllocationProp_st_allocFlags_s(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['requestedHandleTypes : ' + str(self.requestedHandleTypes)]
            str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            str_list += ['win32HandleMetaData : ' + hex(self.win32HandleMetaData)]
            str_list += ['allocFlags :\n' + '\n'.join(['    ' + line for line in str(self.allocFlags).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUmemAllocationType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUmemAllocationType):
        pass
        self._ptr[0].type = type.value
    @property
    def requestedHandleTypes(self):
        return CUmemAllocationHandleType(self._ptr[0].requestedHandleTypes)
    @requestedHandleTypes.setter
    def requestedHandleTypes(self, requestedHandleTypes not None : CUmemAllocationHandleType):
        pass
        self._ptr[0].requestedHandleTypes = requestedHandleTypes.value
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        pass
        for _attr in dir(location):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._location, _attr, getattr(location, _attr))
    @property
    def win32HandleMetaData(self):
        return <void_ptr>self._ptr[0].win32HandleMetaData
    @win32HandleMetaData.setter
    def win32HandleMetaData(self, win32HandleMetaData):
        _cwin32HandleMetaData = utils.HelperInputVoidPtr(win32HandleMetaData)
        self._ptr[0].win32HandleMetaData = <void*><void_ptr>_cwin32HandleMetaData.cptr
    @property
    def allocFlags(self):
        return self._allocFlags
    @allocFlags.setter
    def allocFlags(self, allocFlags not None : _CUmemAllocationProp_v1_CUmemAllocationProp_v1_CUmemAllocationProp_st_allocFlags_s):
        pass
        for _attr in dir(allocFlags):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._allocFlags, _attr, getattr(allocFlags, _attr))

cdef class CUmemAccessDesc_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmemAccessDesc_st *>calloc(1, sizeof(ccuda.CUmemAccessDesc_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmemAccessDesc_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmemAccessDesc_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._location = CUmemLocation(_ptr=<void_ptr>&self._ptr[0].location)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        pass
        for _attr in dir(location):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._location, _attr, getattr(location, _attr))
    @property
    def flags(self):
        return CUmemAccess_flags(self._ptr[0].flags)
    @flags.setter
    def flags(self, flags not None : CUmemAccess_flags):
        pass
        self._ptr[0].flags = flags.value

cdef class CUmemPoolProps_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmemPoolProps_st *>calloc(1, sizeof(ccuda.CUmemPoolProps_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmemPoolProps_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmemPoolProps_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._location = CUmemLocation(_ptr=<void_ptr>&self._ptr[0].location)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['allocType : ' + str(self.allocType)]
            str_list += ['handleTypes : ' + str(self.handleTypes)]
            str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            str_list += ['win32SecurityAttributes : ' + hex(self.win32SecurityAttributes)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def allocType(self):
        return CUmemAllocationType(self._ptr[0].allocType)
    @allocType.setter
    def allocType(self, allocType not None : CUmemAllocationType):
        pass
        self._ptr[0].allocType = allocType.value
    @property
    def handleTypes(self):
        return CUmemAllocationHandleType(self._ptr[0].handleTypes)
    @handleTypes.setter
    def handleTypes(self, handleTypes not None : CUmemAllocationHandleType):
        pass
        self._ptr[0].handleTypes = handleTypes.value
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        pass
        for _attr in dir(location):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._location, _attr, getattr(location, _attr))
    @property
    def win32SecurityAttributes(self):
        return <void_ptr>self._ptr[0].win32SecurityAttributes
    @win32SecurityAttributes.setter
    def win32SecurityAttributes(self, win32SecurityAttributes):
        _cwin32SecurityAttributes = utils.HelperInputVoidPtr(win32SecurityAttributes)
        self._ptr[0].win32SecurityAttributes = <void*><void_ptr>_cwin32SecurityAttributes.cptr
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUmemPoolPtrExportData_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUmemPoolPtrExportData_st *>calloc(1, sizeof(ccuda.CUmemPoolPtrExportData_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUmemPoolPtrExportData_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUmemPoolPtrExportData_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_MEM_ALLOC_NODE_PARAMS_st:
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr_owner = True
            self._ptr = <ccuda.CUDA_MEM_ALLOC_NODE_PARAMS_st *>calloc(1, sizeof(ccuda.CUDA_MEM_ALLOC_NODE_PARAMS_st))
            if self._ptr is NULL:
                raise MemoryError('Failed to allocate length x size memory: 1x' + str(sizeof(ccuda.CUDA_MEM_ALLOC_NODE_PARAMS_st)))
        else:
            self._ptr_owner = False
            self._ptr = <ccuda.CUDA_MEM_ALLOC_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._poolProps = CUmemPoolProps(_ptr=<void_ptr>&self._ptr[0].poolProps)
        self._dptr = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dptr)
    def __dealloc__(self):
        if self._ptr_owner is True and self._ptr is not NULL:
            free(self._ptr)
        if self._accessDescs is not NULL:
            free(self._accessDescs)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['poolProps :\n' + '\n'.join(['    ' + line for line in str(self.poolProps).splitlines()])]
            str_list += ['accessDescs : ' + str(self.accessDescs)]
            str_list += ['accessDescCount : ' + str(self.accessDescCount)]
            str_list += ['bytesize : ' + str(self.bytesize)]
            str_list += ['dptr : ' + str(self.dptr)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def poolProps(self):
        return self._poolProps
    @poolProps.setter
    def poolProps(self, poolProps not None : CUmemPoolProps):
        pass
        for _attr in dir(poolProps):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._poolProps, _attr, getattr(poolProps, _attr))
    @property
    def accessDescs(self):
        arrs = [<void_ptr>self._ptr[0].accessDescs + x*sizeof(ccuda.CUmemAccessDesc) for x in range(self._accessDescs_length)]
        return [CUmemAccessDesc(_ptr=arr) for arr in arrs]
    @accessDescs.setter
    def accessDescs(self, val):
        if len(val) == 0:
            free(self._accessDescs)
            self._accessDescs_length = 0
            self._ptr[0].accessDescs = NULL
        else:
            if self._accessDescs_length != <size_t>len(val):
                free(self._accessDescs)
                self._accessDescs = <ccuda.CUmemAccessDesc*> calloc(len(val), sizeof(ccuda.CUmemAccessDesc))
                if self._accessDescs is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUmemAccessDesc)))
                self._accessDescs_length = <size_t>len(val)
                self._ptr[0].accessDescs = self._accessDescs
            for idx in range(len(val)):
                memcpy(&self._accessDescs[idx], (<CUmemAccessDesc>val[idx])._ptr, sizeof(ccuda.CUmemAccessDesc))
    @property
    def accessDescCount(self):
        return self._ptr[0].accessDescCount
    @accessDescCount.setter
    def accessDescCount(self, size_t accessDescCount):
        pass
        self._ptr[0].accessDescCount = accessDescCount
    @property
    def bytesize(self):
        return self._ptr[0].bytesize
    @bytesize.setter
    def bytesize(self, size_t bytesize):
        pass
        self._ptr[0].bytesize = bytesize
    @property
    def dptr(self):
        return self._dptr
    @dptr.setter
    def dptr(self, dptr : CUdeviceptr):
        pass
        self._dptr._ptr[0] = <ccuda.CUdeviceptr> NULL if dptr == None else (<CUdeviceptr>dptr)._ptr[0]

@cython.embedsignature(True)
def cuGetErrorString(error not None : CUresult):
    cdef ccuda.CUresult cerror = error.value
    cdef const char* pStr = NULL
    err = ccuda.cuGetErrorString(cerror, &pStr)
    return (CUresult(err), <bytes>pStr)

@cython.embedsignature(True)
def cuGetErrorName(error not None : CUresult):
    cdef ccuda.CUresult cerror = error.value
    cdef const char* pStr = NULL
    err = ccuda.cuGetErrorName(cerror, &pStr)
    return (CUresult(err), <bytes>pStr)

@cython.embedsignature(True)
def cuInit(unsigned int Flags):
    err = ccuda.cuInit(Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDriverGetVersion():
    cdef int driverVersion = 0
    err = ccuda.cuDriverGetVersion(&driverVersion)
    return (CUresult(err), driverVersion)

@cython.embedsignature(True)
def cuDeviceGet(int ordinal):
    cdef CUdevice device = CUdevice()
    err = ccuda.cuDeviceGet(device._ptr, ordinal)
    return (CUresult(err), device)

@cython.embedsignature(True)
def cuDeviceGetCount():
    cdef int count = 0
    err = ccuda.cuDeviceGetCount(&count)
    return (CUresult(err), count)

@cython.embedsignature(True)
def cuDeviceGetName(int length, dev not None : CUdevice):
    cdef char* name = <char*>calloc(1, length)
    err = ccuda.cuDeviceGetName(name, length, dev._ptr[0])
    return (CUresult(err), <bytes>name)

@cython.embedsignature(True)
def cuDeviceGetUuid(dev not None : CUdevice):
    cdef CUuuid uuid = CUuuid()
    err = ccuda.cuDeviceGetUuid(uuid._ptr, dev._ptr[0])
    return (CUresult(err), uuid)

@cython.embedsignature(True)
def cuDeviceGetUuid_v2(dev not None : CUdevice):
    cdef CUuuid uuid = CUuuid()
    err = ccuda.cuDeviceGetUuid_v2(uuid._ptr, dev._ptr[0])
    return (CUresult(err), uuid)

@cython.embedsignature(True)
def cuDeviceGetLuid(dev not None : CUdevice):
    cdef char luid[8]
    cdef unsigned int deviceNodeMask = 0
    err = ccuda.cuDeviceGetLuid(luid, &deviceNodeMask, dev._ptr[0])
    return (CUresult(err), <bytes>luid, deviceNodeMask)

@cython.embedsignature(True)
def cuDeviceTotalMem(dev not None : CUdevice):
    cdef size_t numbytes = 0
    err = ccuda.cuDeviceTotalMem(&numbytes, dev._ptr[0])
    return (CUresult(err), numbytes)

@cython.embedsignature(True)
def cuDeviceGetTexture1DLinearMaxWidth(pformat not None : CUarray_format, unsigned numChannels, dev not None : CUdevice):
    cdef size_t maxWidthInElements = 0
    cdef ccuda.CUarray_format cpformat = pformat.value
    err = ccuda.cuDeviceGetTexture1DLinearMaxWidth(&maxWidthInElements, cpformat, numChannels, dev._ptr[0])
    return (CUresult(err), maxWidthInElements)

@cython.embedsignature(True)
def cuDeviceGetAttribute(attrib not None : CUdevice_attribute, dev not None : CUdevice):
    cdef int pi = 0
    cdef ccuda.CUdevice_attribute cattrib = attrib.value
    err = ccuda.cuDeviceGetAttribute(&pi, cattrib, dev._ptr[0])
    return (CUresult(err), pi)

@cython.embedsignature(True)
def cuDeviceGetNvSciSyncAttributes(dev not None : CUdevice, int flags):
    cdef void_ptr nvSciSyncAttrList = 0
    cdef void* cnvSciSyncAttrList_ptr = <void*>nvSciSyncAttrList
    err = ccuda.cuDeviceGetNvSciSyncAttributes(cnvSciSyncAttrList_ptr, dev._ptr[0], flags)
    return (CUresult(err), nvSciSyncAttrList)

@cython.embedsignature(True)
def cuDeviceSetMemPool(dev not None : CUdevice, pool not None : CUmemoryPool):
    err = ccuda.cuDeviceSetMemPool(dev._ptr[0], pool._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetMemPool(dev not None : CUdevice):
    cdef CUmemoryPool pool = CUmemoryPool()
    err = ccuda.cuDeviceGetMemPool(pool._ptr, dev._ptr[0])
    return (CUresult(err), pool)

@cython.embedsignature(True)
def cuDeviceGetDefaultMemPool(dev not None : CUdevice):
    cdef CUmemoryPool pool_out = CUmemoryPool()
    err = ccuda.cuDeviceGetDefaultMemPool(pool_out._ptr, dev._ptr[0])
    return (CUresult(err), pool_out)

@cython.embedsignature(True)
def cuDeviceGetProperties(dev not None : CUdevice):
    cdef CUdevprop prop = CUdevprop()
    err = ccuda.cuDeviceGetProperties(prop._ptr, dev._ptr[0])
    return (CUresult(err), prop)

@cython.embedsignature(True)
def cuDeviceComputeCapability(dev not None : CUdevice):
    cdef int major = 0
    cdef int minor = 0
    err = ccuda.cuDeviceComputeCapability(&major, &minor, dev._ptr[0])
    return (CUresult(err), major, minor)

@cython.embedsignature(True)
def cuDevicePrimaryCtxRetain(dev not None : CUdevice):
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuDevicePrimaryCtxRetain(pctx._ptr, dev._ptr[0])
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuDevicePrimaryCtxRelease(dev not None : CUdevice):
    err = ccuda.cuDevicePrimaryCtxRelease(dev._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDevicePrimaryCtxSetFlags(dev not None : CUdevice, unsigned int flags):
    err = ccuda.cuDevicePrimaryCtxSetFlags(dev._ptr[0], flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDevicePrimaryCtxGetState(dev not None : CUdevice):
    cdef unsigned int flags = 0
    cdef int active = 0
    err = ccuda.cuDevicePrimaryCtxGetState(dev._ptr[0], &flags, &active)
    return (CUresult(err), flags, active)

@cython.embedsignature(True)
def cuDevicePrimaryCtxReset(dev not None : CUdevice):
    err = ccuda.cuDevicePrimaryCtxReset(dev._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetExecAffinitySupport(typename not None : CUexecAffinityType, dev not None : CUdevice):
    cdef int pi = 0
    cdef ccuda.CUexecAffinityType ctypename = typename.value
    err = ccuda.cuDeviceGetExecAffinitySupport(&pi, ctypename, dev._ptr[0])
    return (CUresult(err), pi)

@cython.embedsignature(True)
def cuCtxCreate(unsigned int flags, dev not None : CUdevice):
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuCtxCreate(pctx._ptr, flags, dev._ptr[0])
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxCreate_v3(paramsArray : List[CUexecAffinityParam], int numParams, unsigned int flags, dev not None : CUdevice):
    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (CUexecAffinityParam)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected List[cudapython.ccuda.CUexecAffinityParam]")
    cdef CUcontext pctx = CUcontext()
    cdef ccuda.CUexecAffinityParam* cparamsArray = NULL
    if len(paramsArray) > 0:
        cparamsArray = <ccuda.CUexecAffinityParam*> calloc(len(paramsArray), sizeof(ccuda.CUexecAffinityParam))
        if cparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(ccuda.CUexecAffinityParam)))
        for idx in range(len(paramsArray)):
            memcpy(&cparamsArray[idx], (<CUexecAffinityParam>paramsArray[idx])._ptr, sizeof(ccuda.CUexecAffinityParam))

    err = ccuda.cuCtxCreate_v3(pctx._ptr, (<CUexecAffinityParam>paramsArray[0])._ptr if len(paramsArray) == 1 else cparamsArray, numParams, flags, dev._ptr[0])
    if cparamsArray is not NULL:
        free(cparamsArray)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxDestroy(ctx not None : CUcontext):
    err = ccuda.cuCtxDestroy(ctx._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxPushCurrent(ctx not None : CUcontext):
    err = ccuda.cuCtxPushCurrent(ctx._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxPopCurrent():
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuCtxPopCurrent(pctx._ptr)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxSetCurrent(ctx not None : CUcontext):
    err = ccuda.cuCtxSetCurrent(ctx._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetCurrent():
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuCtxGetCurrent(pctx._ptr)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxGetDevice():
    cdef CUdevice device = CUdevice()
    err = ccuda.cuCtxGetDevice(device._ptr)
    return (CUresult(err), device)

@cython.embedsignature(True)
def cuCtxGetFlags():
    cdef unsigned int flags = 0
    err = ccuda.cuCtxGetFlags(&flags)
    return (CUresult(err), flags)

@cython.embedsignature(True)
def cuCtxSynchronize():
    err = ccuda.cuCtxSynchronize()
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxSetLimit(limit not None : CUlimit, size_t value):
    cdef ccuda.CUlimit climit = limit.value
    err = ccuda.cuCtxSetLimit(climit, value)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetLimit(limit not None : CUlimit):
    cdef size_t pvalue = 0
    cdef ccuda.CUlimit climit = limit.value
    err = ccuda.cuCtxGetLimit(&pvalue, climit)
    return (CUresult(err), pvalue)

@cython.embedsignature(True)
def cuCtxGetCacheConfig():
    cdef ccuda.CUfunc_cache pconfig
    err = ccuda.cuCtxGetCacheConfig(&pconfig)
    return (CUresult(err), CUfunc_cache(pconfig))

@cython.embedsignature(True)
def cuCtxSetCacheConfig(config not None : CUfunc_cache):
    cdef ccuda.CUfunc_cache cconfig = config.value
    err = ccuda.cuCtxSetCacheConfig(cconfig)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetSharedMemConfig():
    cdef ccuda.CUsharedconfig pConfig
    err = ccuda.cuCtxGetSharedMemConfig(&pConfig)
    return (CUresult(err), CUsharedconfig(pConfig))

@cython.embedsignature(True)
def cuCtxSetSharedMemConfig(config not None : CUsharedconfig):
    cdef ccuda.CUsharedconfig cconfig = config.value
    err = ccuda.cuCtxSetSharedMemConfig(cconfig)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetApiVersion(ctx not None : CUcontext):
    cdef unsigned int version = 0
    err = ccuda.cuCtxGetApiVersion(ctx._ptr[0], &version)
    return (CUresult(err), version)

@cython.embedsignature(True)
def cuCtxGetStreamPriorityRange():
    cdef int leastPriority = 0
    cdef int greatestPriority = 0
    err = ccuda.cuCtxGetStreamPriorityRange(&leastPriority, &greatestPriority)
    return (CUresult(err), leastPriority, greatestPriority)

@cython.embedsignature(True)
def cuCtxResetPersistingL2Cache():
    err = ccuda.cuCtxResetPersistingL2Cache()
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetExecAffinity(typename not None : CUexecAffinityType):
    cdef CUexecAffinityParam pExecAffinity = CUexecAffinityParam()
    cdef ccuda.CUexecAffinityType ctypename = typename.value
    err = ccuda.cuCtxGetExecAffinity(pExecAffinity._ptr, ctypename)
    return (CUresult(err), pExecAffinity)

@cython.embedsignature(True)
def cuCtxAttach(unsigned int flags):
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuCtxAttach(pctx._ptr, flags)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxDetach(ctx not None : CUcontext):
    err = ccuda.cuCtxDetach(ctx._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuModuleLoad(char* fname):
    cdef CUmodule module = CUmodule()
    err = ccuda.cuModuleLoad(module._ptr, fname)
    return (CUresult(err), module)

@cython.embedsignature(True)
def cuModuleLoadData(image):
    cdef CUmodule module = CUmodule()
    cimage = utils.HelperInputVoidPtr(image)
    cdef void* cimage_ptr = <void*><void_ptr>cimage.cptr
    err = ccuda.cuModuleLoadData(module._ptr, cimage_ptr)
    return (CUresult(err), module)

@cython.embedsignature(True)
def cuModuleLoadDataEx(image, unsigned int numOptions, options : List[CUjit_option], optionValues : List[Any]):
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected List[cudapython.ccuda.CUjit_option]")
    cdef CUmodule module = CUmodule()
    cimage = utils.HelperInputVoidPtr(image)
    cdef void* cimage_ptr = <void*><void_ptr>cimage.cptr
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[ccuda.CUjit_option] coptions = [pyoptions.value for pyoptions in (options)]
    pylist = [utils.HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    err = ccuda.cuModuleLoadDataEx(module._ptr, cimage_ptr, numOptions, coptions.data(), <void**><void_ptr>voidStarHelper.cptr)
    return (CUresult(err), module)

@cython.embedsignature(True)
def cuModuleLoadFatBinary(fatCubin):
    cdef CUmodule module = CUmodule()
    cfatCubin = utils.HelperInputVoidPtr(fatCubin)
    cdef void* cfatCubin_ptr = <void*><void_ptr>cfatCubin.cptr
    err = ccuda.cuModuleLoadFatBinary(module._ptr, cfatCubin_ptr)
    return (CUresult(err), module)

@cython.embedsignature(True)
def cuModuleUnload(hmod not None : CUmodule):
    err = ccuda.cuModuleUnload(hmod._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuModuleGetFunction(hmod not None : CUmodule, char* name):
    cdef CUfunction hfunc = CUfunction()
    err = ccuda.cuModuleGetFunction(hfunc._ptr, hmod._ptr[0], name)
    return (CUresult(err), hfunc)

@cython.embedsignature(True)
def cuModuleGetGlobal(hmod not None : CUmodule, char* name):
    cdef CUdeviceptr dptr = CUdeviceptr()
    cdef size_t numbytes = 0
    err = ccuda.cuModuleGetGlobal(dptr._ptr, &numbytes, hmod._ptr[0], name)
    return (CUresult(err), dptr, numbytes)

@cython.embedsignature(True)
def cuModuleGetTexRef(hmod not None : CUmodule, char* name):
    cdef CUtexref pTexRef = CUtexref()
    err = ccuda.cuModuleGetTexRef(pTexRef._ptr, hmod._ptr[0], name)
    return (CUresult(err), pTexRef)

@cython.embedsignature(True)
def cuModuleGetSurfRef(hmod not None : CUmodule, char* name):
    cdef CUsurfref pSurfRef = CUsurfref()
    err = ccuda.cuModuleGetSurfRef(pSurfRef._ptr, hmod._ptr[0], name)
    return (CUresult(err), pSurfRef)

@cython.embedsignature(True)
def cuLinkCreate(unsigned int numOptions, options : List[CUjit_option], optionValues : List[Any]):
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected List[cudapython.ccuda.CUjit_option]")
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[ccuda.CUjit_option] coptions = [pyoptions.value for pyoptions in (options)]
    pylist = [utils.HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    cdef CUlinkState stateOut = CUlinkState()
    err = ccuda.cuLinkCreate(numOptions, coptions.data(), <void**><void_ptr>voidStarHelper.cptr, stateOut._ptr)
    return (CUresult(err), stateOut)

@cython.embedsignature(True)
def cuLinkAddData(state not None : CUlinkState, typename not None : CUjitInputType, data, size_t size, char* name, unsigned int numOptions, options : List[CUjit_option], optionValues : List[Any]):
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected List[cudapython.ccuda.CUjit_option]")
    cdef ccuda.CUjitInputType ctypename = typename.value
    cdata = utils.HelperInputVoidPtr(data)
    cdef void* cdata_ptr = <void*><void_ptr>cdata.cptr
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[ccuda.CUjit_option] coptions = [pyoptions.value for pyoptions in (options)]
    pylist = [utils.HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    err = ccuda.cuLinkAddData(state._ptr[0], ctypename, cdata_ptr, size, name, numOptions, coptions.data(), <void**><void_ptr>voidStarHelper.cptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLinkAddFile(state not None : CUlinkState, typename not None : CUjitInputType, char* path, unsigned int numOptions, options : List[CUjit_option], optionValues : List[Any]):
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected List[cudapython.ccuda.CUjit_option]")
    cdef ccuda.CUjitInputType ctypename = typename.value
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[ccuda.CUjit_option] coptions = [pyoptions.value for pyoptions in (options)]
    pylist = [utils.HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    err = ccuda.cuLinkAddFile(state._ptr[0], ctypename, path, numOptions, coptions.data(), <void**><void_ptr>voidStarHelper.cptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLinkComplete(state not None : CUlinkState):
    cdef void_ptr cubinOut = 0
    cdef size_t sizeOut = 0
    err = ccuda.cuLinkComplete(state._ptr[0], <void**>&cubinOut, &sizeOut)
    return (CUresult(err), cubinOut, sizeOut)

@cython.embedsignature(True)
def cuLinkDestroy(state not None : CUlinkState):
    err = ccuda.cuLinkDestroy(state._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemGetInfo():
    cdef size_t free = 0
    cdef size_t total = 0
    err = ccuda.cuMemGetInfo(&free, &total)
    return (CUresult(err), free, total)

@cython.embedsignature(True)
def cuMemAlloc(size_t bytesize):
    cdef CUdeviceptr dptr = CUdeviceptr()
    err = ccuda.cuMemAlloc(dptr._ptr, bytesize)
    return (CUresult(err), dptr)

@cython.embedsignature(True)
def cuMemAllocPitch(size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes):
    cdef CUdeviceptr dptr = CUdeviceptr()
    cdef size_t pPitch = 0
    err = ccuda.cuMemAllocPitch(dptr._ptr, &pPitch, WidthInBytes, Height, ElementSizeBytes)
    return (CUresult(err), dptr, pPitch)

@cython.embedsignature(True)
def cuMemFree(dptr not None : CUdeviceptr):
    err = ccuda.cuMemFree(dptr._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemGetAddressRange(dptr not None : CUdeviceptr):
    cdef CUdeviceptr pbase = CUdeviceptr()
    cdef size_t psize = 0
    err = ccuda.cuMemGetAddressRange(pbase._ptr, &psize, dptr._ptr[0])
    return (CUresult(err), pbase, psize)

@cython.embedsignature(True)
def cuMemAllocHost(size_t bytesize):
    cdef void_ptr pp = 0
    err = ccuda.cuMemAllocHost(<void**>&pp, bytesize)
    return (CUresult(err), pp)

@cython.embedsignature(True)
def cuMemFreeHost(p):
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemFreeHost(cp_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemHostAlloc(size_t bytesize, unsigned int Flags):
    cdef void_ptr pp = 0
    err = ccuda.cuMemHostAlloc(<void**>&pp, bytesize, Flags)
    return (CUresult(err), pp)

@cython.embedsignature(True)
def cuMemHostGetDevicePointer(p, unsigned int Flags):
    cdef CUdeviceptr pdptr = CUdeviceptr()
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemHostGetDevicePointer(pdptr._ptr, cp_ptr, Flags)
    return (CUresult(err), pdptr)

@cython.embedsignature(True)
def cuMemHostGetFlags(p):
    cdef unsigned int pFlags = 0
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemHostGetFlags(&pFlags, cp_ptr)
    return (CUresult(err), pFlags)

@cython.embedsignature(True)
def cuMemAllocManaged(size_t bytesize, unsigned int flags):
    cdef CUdeviceptr dptr = CUdeviceptr()
    err = ccuda.cuMemAllocManaged(dptr._ptr, bytesize, flags)
    return (CUresult(err), dptr)

@cython.embedsignature(True)
def cuDeviceGetByPCIBusId(char* pciBusId):
    cdef CUdevice dev = CUdevice()
    err = ccuda.cuDeviceGetByPCIBusId(dev._ptr, pciBusId)
    return (CUresult(err), dev)

@cython.embedsignature(True)
def cuDeviceGetPCIBusId(int length, dev not None : CUdevice):
    cdef char* pciBusId = <char*>calloc(1, length)
    err = ccuda.cuDeviceGetPCIBusId(pciBusId, length, dev._ptr[0])
    return (CUresult(err), <bytes>pciBusId)

@cython.embedsignature(True)
def cuIpcGetEventHandle(event not None : CUevent):
    cdef CUipcEventHandle pHandle = CUipcEventHandle()
    err = ccuda.cuIpcGetEventHandle(pHandle._ptr, event._ptr[0])
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuIpcOpenEventHandle(handle not None : CUipcEventHandle):
    cdef CUevent phEvent = CUevent()
    err = ccuda.cuIpcOpenEventHandle(phEvent._ptr, handle._ptr[0])
    return (CUresult(err), phEvent)

@cython.embedsignature(True)
def cuIpcGetMemHandle(dptr not None : CUdeviceptr):
    cdef CUipcMemHandle pHandle = CUipcMemHandle()
    err = ccuda.cuIpcGetMemHandle(pHandle._ptr, dptr._ptr[0])
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuIpcOpenMemHandle(handle not None : CUipcMemHandle, unsigned int Flags):
    cdef CUdeviceptr pdptr = CUdeviceptr()
    err = ccuda.cuIpcOpenMemHandle(pdptr._ptr, handle._ptr[0], Flags)
    return (CUresult(err), pdptr)

@cython.embedsignature(True)
def cuIpcCloseMemHandle(dptr not None : CUdeviceptr):
    err = ccuda.cuIpcCloseMemHandle(dptr._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemHostRegister(p, size_t bytesize, unsigned int Flags):
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemHostRegister(cp_ptr, bytesize, Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemHostUnregister(p):
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemHostUnregister(cp_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy(dst not None : CUdeviceptr, src not None : CUdeviceptr, size_t ByteCount):
    err = ccuda.cuMemcpy(dst._ptr[0], src._ptr[0], ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyPeer(dstDevice not None : CUdeviceptr, dstContext not None : CUcontext, srcDevice not None : CUdeviceptr, srcContext not None : CUcontext, size_t ByteCount):
    err = ccuda.cuMemcpyPeer(dstDevice._ptr[0], dstContext._ptr[0], srcDevice._ptr[0], srcContext._ptr[0], ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyHtoD(dstDevice not None : CUdeviceptr, srcHost, size_t ByteCount):
    csrcHost = utils.HelperInputVoidPtr(srcHost)
    cdef void* csrcHost_ptr = <void*><void_ptr>csrcHost.cptr
    err = ccuda.cuMemcpyHtoD(dstDevice._ptr[0], csrcHost_ptr, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoH(dstHost, srcDevice not None : CUdeviceptr, size_t ByteCount):
    cdstHost = utils.HelperInputVoidPtr(dstHost)
    cdef void* cdstHost_ptr = <void*><void_ptr>cdstHost.cptr
    err = ccuda.cuMemcpyDtoH(cdstHost_ptr, srcDevice._ptr[0], ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoD(dstDevice not None : CUdeviceptr, srcDevice not None : CUdeviceptr, size_t ByteCount):
    err = ccuda.cuMemcpyDtoD(dstDevice._ptr[0], srcDevice._ptr[0], ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoA(dstArray not None : CUarray, size_t dstOffset, srcDevice not None : CUdeviceptr, size_t ByteCount):
    err = ccuda.cuMemcpyDtoA(dstArray._ptr[0], dstOffset, srcDevice._ptr[0], ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAtoD(dstDevice not None : CUdeviceptr, srcArray not None : CUarray, size_t srcOffset, size_t ByteCount):
    err = ccuda.cuMemcpyAtoD(dstDevice._ptr[0], srcArray._ptr[0], srcOffset, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyHtoA(dstArray not None : CUarray, size_t dstOffset, srcHost, size_t ByteCount):
    csrcHost = utils.HelperInputVoidPtr(srcHost)
    cdef void* csrcHost_ptr = <void*><void_ptr>csrcHost.cptr
    err = ccuda.cuMemcpyHtoA(dstArray._ptr[0], dstOffset, csrcHost_ptr, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAtoH(dstHost, srcArray not None : CUarray, size_t srcOffset, size_t ByteCount):
    cdstHost = utils.HelperInputVoidPtr(dstHost)
    cdef void* cdstHost_ptr = <void*><void_ptr>cdstHost.cptr
    err = ccuda.cuMemcpyAtoH(cdstHost_ptr, srcArray._ptr[0], srcOffset, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAtoA(dstArray not None : CUarray, size_t dstOffset, srcArray not None : CUarray, size_t srcOffset, size_t ByteCount):
    err = ccuda.cuMemcpyAtoA(dstArray._ptr[0], dstOffset, srcArray._ptr[0], srcOffset, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy2D(pCopy : CUDA_MEMCPY2D):
    cdef ccuda.CUDA_MEMCPY2D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy2D(cpCopy_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy2DUnaligned(pCopy : CUDA_MEMCPY2D):
    cdef ccuda.CUDA_MEMCPY2D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy2DUnaligned(cpCopy_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy3D(pCopy : CUDA_MEMCPY3D):
    cdef ccuda.CUDA_MEMCPY3D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy3D(cpCopy_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy3DPeer(pCopy : CUDA_MEMCPY3D_PEER):
    cdef ccuda.CUDA_MEMCPY3D_PEER* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy3DPeer(cpCopy_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAsync(dst not None : CUdeviceptr, src not None : CUdeviceptr, size_t ByteCount, hStream not None : CUstream):
    err = ccuda.cuMemcpyAsync(dst._ptr[0], src._ptr[0], ByteCount, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyPeerAsync(dstDevice not None : CUdeviceptr, dstContext not None : CUcontext, srcDevice not None : CUdeviceptr, srcContext not None : CUcontext, size_t ByteCount, hStream not None : CUstream):
    err = ccuda.cuMemcpyPeerAsync(dstDevice._ptr[0], dstContext._ptr[0], srcDevice._ptr[0], srcContext._ptr[0], ByteCount, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyHtoDAsync(dstDevice not None : CUdeviceptr, srcHost, size_t ByteCount, hStream not None : CUstream):
    csrcHost = utils.HelperInputVoidPtr(srcHost)
    cdef void* csrcHost_ptr = <void*><void_ptr>csrcHost.cptr
    err = ccuda.cuMemcpyHtoDAsync(dstDevice._ptr[0], csrcHost_ptr, ByteCount, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoHAsync(dstHost, srcDevice not None : CUdeviceptr, size_t ByteCount, hStream not None : CUstream):
    cdstHost = utils.HelperInputVoidPtr(dstHost)
    cdef void* cdstHost_ptr = <void*><void_ptr>cdstHost.cptr
    err = ccuda.cuMemcpyDtoHAsync(cdstHost_ptr, srcDevice._ptr[0], ByteCount, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoDAsync(dstDevice not None : CUdeviceptr, srcDevice not None : CUdeviceptr, size_t ByteCount, hStream not None : CUstream):
    err = ccuda.cuMemcpyDtoDAsync(dstDevice._ptr[0], srcDevice._ptr[0], ByteCount, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyHtoAAsync(dstArray not None : CUarray, size_t dstOffset, srcHost, size_t ByteCount, hStream not None : CUstream):
    csrcHost = utils.HelperInputVoidPtr(srcHost)
    cdef void* csrcHost_ptr = <void*><void_ptr>csrcHost.cptr
    err = ccuda.cuMemcpyHtoAAsync(dstArray._ptr[0], dstOffset, csrcHost_ptr, ByteCount, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAtoHAsync(dstHost, srcArray not None : CUarray, size_t srcOffset, size_t ByteCount, hStream not None : CUstream):
    cdstHost = utils.HelperInputVoidPtr(dstHost)
    cdef void* cdstHost_ptr = <void*><void_ptr>cdstHost.cptr
    err = ccuda.cuMemcpyAtoHAsync(cdstHost_ptr, srcArray._ptr[0], srcOffset, ByteCount, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy2DAsync(pCopy : CUDA_MEMCPY2D, hStream not None : CUstream):
    cdef ccuda.CUDA_MEMCPY2D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy2DAsync(cpCopy_ptr, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy3DAsync(pCopy : CUDA_MEMCPY3D, hStream not None : CUstream):
    cdef ccuda.CUDA_MEMCPY3D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy3DAsync(cpCopy_ptr, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy3DPeerAsync(pCopy : CUDA_MEMCPY3D_PEER, hStream not None : CUstream):
    cdef ccuda.CUDA_MEMCPY3D_PEER* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy3DPeerAsync(cpCopy_ptr, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD8(dstDevice not None : CUdeviceptr, unsigned char uc, size_t N):
    err = ccuda.cuMemsetD8(dstDevice._ptr[0], uc, N)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD16(dstDevice not None : CUdeviceptr, unsigned short us, size_t N):
    err = ccuda.cuMemsetD16(dstDevice._ptr[0], us, N)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD32(dstDevice not None : CUdeviceptr, unsigned int ui, size_t N):
    err = ccuda.cuMemsetD32(dstDevice._ptr[0], ui, N)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D8(dstDevice not None : CUdeviceptr, size_t dstPitch, unsigned char uc, size_t Width, size_t Height):
    err = ccuda.cuMemsetD2D8(dstDevice._ptr[0], dstPitch, uc, Width, Height)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D16(dstDevice not None : CUdeviceptr, size_t dstPitch, unsigned short us, size_t Width, size_t Height):
    err = ccuda.cuMemsetD2D16(dstDevice._ptr[0], dstPitch, us, Width, Height)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D32(dstDevice not None : CUdeviceptr, size_t dstPitch, unsigned int ui, size_t Width, size_t Height):
    err = ccuda.cuMemsetD2D32(dstDevice._ptr[0], dstPitch, ui, Width, Height)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD8Async(dstDevice not None : CUdeviceptr, unsigned char uc, size_t N, hStream not None : CUstream):
    err = ccuda.cuMemsetD8Async(dstDevice._ptr[0], uc, N, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD16Async(dstDevice not None : CUdeviceptr, unsigned short us, size_t N, hStream not None : CUstream):
    err = ccuda.cuMemsetD16Async(dstDevice._ptr[0], us, N, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD32Async(dstDevice not None : CUdeviceptr, unsigned int ui, size_t N, hStream not None : CUstream):
    err = ccuda.cuMemsetD32Async(dstDevice._ptr[0], ui, N, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D8Async(dstDevice not None : CUdeviceptr, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, hStream not None : CUstream):
    err = ccuda.cuMemsetD2D8Async(dstDevice._ptr[0], dstPitch, uc, Width, Height, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D16Async(dstDevice not None : CUdeviceptr, size_t dstPitch, unsigned short us, size_t Width, size_t Height, hStream not None : CUstream):
    err = ccuda.cuMemsetD2D16Async(dstDevice._ptr[0], dstPitch, us, Width, Height, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D32Async(dstDevice not None : CUdeviceptr, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, hStream not None : CUstream):
    err = ccuda.cuMemsetD2D32Async(dstDevice._ptr[0], dstPitch, ui, Width, Height, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuArrayCreate(pAllocateArray : CUDA_ARRAY_DESCRIPTOR):
    cdef CUarray pHandle = CUarray()
    cdef ccuda.CUDA_ARRAY_DESCRIPTOR* cpAllocateArray_ptr = pAllocateArray._ptr if pAllocateArray != None else NULL
    err = ccuda.cuArrayCreate(pHandle._ptr, cpAllocateArray_ptr)
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuArrayGetDescriptor(hArray not None : CUarray):
    cdef CUDA_ARRAY_DESCRIPTOR pArrayDescriptor = CUDA_ARRAY_DESCRIPTOR()
    err = ccuda.cuArrayGetDescriptor(pArrayDescriptor._ptr, hArray._ptr[0])
    return (CUresult(err), pArrayDescriptor)

@cython.embedsignature(True)
def cuArrayGetSparseProperties(array not None : CUarray):
    cdef CUDA_ARRAY_SPARSE_PROPERTIES sparseProperties = CUDA_ARRAY_SPARSE_PROPERTIES()
    err = ccuda.cuArrayGetSparseProperties(sparseProperties._ptr, array._ptr[0])
    return (CUresult(err), sparseProperties)

@cython.embedsignature(True)
def cuMipmappedArrayGetSparseProperties(mipmap not None : CUmipmappedArray):
    cdef CUDA_ARRAY_SPARSE_PROPERTIES sparseProperties = CUDA_ARRAY_SPARSE_PROPERTIES()
    err = ccuda.cuMipmappedArrayGetSparseProperties(sparseProperties._ptr, mipmap._ptr[0])
    return (CUresult(err), sparseProperties)

@cython.embedsignature(True)
def cuArrayGetPlane(hArray not None : CUarray, unsigned int planeIdx):
    cdef CUarray pPlaneArray = CUarray()
    err = ccuda.cuArrayGetPlane(pPlaneArray._ptr, hArray._ptr[0], planeIdx)
    return (CUresult(err), pPlaneArray)

@cython.embedsignature(True)
def cuArrayDestroy(hArray not None : CUarray):
    err = ccuda.cuArrayDestroy(hArray._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuArray3DCreate(pAllocateArray : CUDA_ARRAY3D_DESCRIPTOR):
    cdef CUarray pHandle = CUarray()
    cdef ccuda.CUDA_ARRAY3D_DESCRIPTOR* cpAllocateArray_ptr = pAllocateArray._ptr if pAllocateArray != None else NULL
    err = ccuda.cuArray3DCreate(pHandle._ptr, cpAllocateArray_ptr)
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuArray3DGetDescriptor(hArray not None : CUarray):
    cdef CUDA_ARRAY3D_DESCRIPTOR pArrayDescriptor = CUDA_ARRAY3D_DESCRIPTOR()
    err = ccuda.cuArray3DGetDescriptor(pArrayDescriptor._ptr, hArray._ptr[0])
    return (CUresult(err), pArrayDescriptor)

@cython.embedsignature(True)
def cuMipmappedArrayCreate(pMipmappedArrayDesc : CUDA_ARRAY3D_DESCRIPTOR, unsigned int numMipmapLevels):
    cdef CUmipmappedArray pHandle = CUmipmappedArray()
    cdef ccuda.CUDA_ARRAY3D_DESCRIPTOR* cpMipmappedArrayDesc_ptr = pMipmappedArrayDesc._ptr if pMipmappedArrayDesc != None else NULL
    err = ccuda.cuMipmappedArrayCreate(pHandle._ptr, cpMipmappedArrayDesc_ptr, numMipmapLevels)
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuMipmappedArrayGetLevel(hMipmappedArray not None : CUmipmappedArray, unsigned int level):
    cdef CUarray pLevelArray = CUarray()
    err = ccuda.cuMipmappedArrayGetLevel(pLevelArray._ptr, hMipmappedArray._ptr[0], level)
    return (CUresult(err), pLevelArray)

@cython.embedsignature(True)
def cuMipmappedArrayDestroy(hMipmappedArray not None : CUmipmappedArray):
    err = ccuda.cuMipmappedArrayDestroy(hMipmappedArray._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemAddressReserve(size_t size, size_t alignment, addr not None : CUdeviceptr, unsigned long long flags):
    cdef CUdeviceptr ptr = CUdeviceptr()
    err = ccuda.cuMemAddressReserve(ptr._ptr, size, alignment, addr._ptr[0], flags)
    return (CUresult(err), ptr)

@cython.embedsignature(True)
def cuMemAddressFree(ptr not None : CUdeviceptr, size_t size):
    err = ccuda.cuMemAddressFree(ptr._ptr[0], size)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemCreate(size_t size, prop : CUmemAllocationProp, unsigned long long flags):
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    cdef ccuda.CUmemAllocationProp* cprop_ptr = prop._ptr if prop != None else NULL
    err = ccuda.cuMemCreate(handle._ptr, size, cprop_ptr, flags)
    return (CUresult(err), handle)

@cython.embedsignature(True)
def cuMemRelease(handle not None : CUmemGenericAllocationHandle):
    err = ccuda.cuMemRelease(handle._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemMap(ptr not None : CUdeviceptr, size_t size, size_t offset, handle not None : CUmemGenericAllocationHandle, unsigned long long flags):
    err = ccuda.cuMemMap(ptr._ptr[0], size, offset, handle._ptr[0], flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemMapArrayAsync(mapInfoList : List[CUarrayMapInfo], unsigned int count, hStream not None : CUstream):
    mapInfoList = [] if mapInfoList is None else mapInfoList
    if not all(isinstance(_x, (CUarrayMapInfo)) for _x in mapInfoList):
        raise TypeError("Argument 'mapInfoList' is not instance of type (expected List[cudapython.ccuda.CUarrayMapInfo]")
    cdef ccuda.CUarrayMapInfo* cmapInfoList = NULL
    if len(mapInfoList) > 0:
        cmapInfoList = <ccuda.CUarrayMapInfo*> calloc(len(mapInfoList), sizeof(ccuda.CUarrayMapInfo))
        if cmapInfoList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(mapInfoList)) + 'x' + str(sizeof(ccuda.CUarrayMapInfo)))
        for idx in range(len(mapInfoList)):
            memcpy(&cmapInfoList[idx], (<CUarrayMapInfo>mapInfoList[idx])._ptr, sizeof(ccuda.CUarrayMapInfo))

    if count > len(mapInfoList): raise RuntimeError("List is too small: " + str(len(mapInfoList)) + " < " + str(count))
    err = ccuda.cuMemMapArrayAsync((<CUarrayMapInfo>mapInfoList[0])._ptr if len(mapInfoList) == 1 else cmapInfoList, count, hStream._ptr[0])
    if cmapInfoList is not NULL:
        free(cmapInfoList)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemUnmap(ptr not None : CUdeviceptr, size_t size):
    err = ccuda.cuMemUnmap(ptr._ptr[0], size)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemSetAccess(ptr not None : CUdeviceptr, size_t size, desc : List[CUmemAccessDesc], size_t count):
    desc = [] if desc is None else desc
    if not all(isinstance(_x, (CUmemAccessDesc)) for _x in desc):
        raise TypeError("Argument 'desc' is not instance of type (expected List[cudapython.ccuda.CUmemAccessDesc]")
    cdef ccuda.CUmemAccessDesc* cdesc = NULL
    if len(desc) > 0:
        cdesc = <ccuda.CUmemAccessDesc*> calloc(len(desc), sizeof(ccuda.CUmemAccessDesc))
        if cdesc is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(desc)) + 'x' + str(sizeof(ccuda.CUmemAccessDesc)))
        for idx in range(len(desc)):
            memcpy(&cdesc[idx], (<CUmemAccessDesc>desc[idx])._ptr, sizeof(ccuda.CUmemAccessDesc))

    if count > <size_t>len(desc): raise RuntimeError("List is too small: " + str(len(desc)) + " < " + str(count))
    err = ccuda.cuMemSetAccess(ptr._ptr[0], size, (<CUmemAccessDesc>desc[0])._ptr if len(desc) == 1 else cdesc, count)
    if cdesc is not NULL:
        free(cdesc)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemGetAccess(location : CUmemLocation, ptr not None : CUdeviceptr):
    cdef unsigned long long flags = 0
    cdef ccuda.CUmemLocation* clocation_ptr = location._ptr if location != None else NULL
    err = ccuda.cuMemGetAccess(&flags, clocation_ptr, ptr._ptr[0])
    return (CUresult(err), flags)

@cython.embedsignature(True)
def cuMemExportToShareableHandle(handle not None : CUmemGenericAllocationHandle, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    cdef void_ptr shareableHandle = 0
    cdef void* cshareableHandle_ptr = <void*>shareableHandle
    cdef ccuda.CUmemAllocationHandleType chandleType = handleType.value
    err = ccuda.cuMemExportToShareableHandle(cshareableHandle_ptr, handle._ptr[0], chandleType, flags)
    return (CUresult(err), shareableHandle)

@cython.embedsignature(True)
def cuMemImportFromShareableHandle(osHandle, shHandleType not None : CUmemAllocationHandleType):
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    cosHandle = utils.HelperInputVoidPtr(osHandle)
    cdef void* cosHandle_ptr = <void*><void_ptr>cosHandle.cptr
    cdef ccuda.CUmemAllocationHandleType cshHandleType = shHandleType.value
    err = ccuda.cuMemImportFromShareableHandle(handle._ptr, cosHandle_ptr, cshHandleType)
    return (CUresult(err), handle)

@cython.embedsignature(True)
def cuMemGetAllocationGranularity(prop : CUmemAllocationProp, option not None : CUmemAllocationGranularity_flags):
    cdef size_t granularity = 0
    cdef ccuda.CUmemAllocationProp* cprop_ptr = prop._ptr if prop != None else NULL
    cdef ccuda.CUmemAllocationGranularity_flags coption = option.value
    err = ccuda.cuMemGetAllocationGranularity(&granularity, cprop_ptr, coption)
    return (CUresult(err), granularity)

@cython.embedsignature(True)
def cuMemGetAllocationPropertiesFromHandle(handle not None : CUmemGenericAllocationHandle):
    cdef CUmemAllocationProp prop = CUmemAllocationProp()
    err = ccuda.cuMemGetAllocationPropertiesFromHandle(prop._ptr, handle._ptr[0])
    return (CUresult(err), prop)

@cython.embedsignature(True)
def cuMemRetainAllocationHandle(addr):
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    caddr = utils.HelperInputVoidPtr(addr)
    cdef void* caddr_ptr = <void*><void_ptr>caddr.cptr
    err = ccuda.cuMemRetainAllocationHandle(handle._ptr, caddr_ptr)
    return (CUresult(err), handle)

@cython.embedsignature(True)
def cuMemFreeAsync(dptr not None : CUdeviceptr, hStream not None : CUstream):
    err = ccuda.cuMemFreeAsync(dptr._ptr[0], hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemAllocAsync(size_t bytesize, hStream not None : CUstream):
    cdef CUdeviceptr dptr = CUdeviceptr()
    err = ccuda.cuMemAllocAsync(dptr._ptr, bytesize, hStream._ptr[0])
    return (CUresult(err), dptr)

@cython.embedsignature(True)
def cuMemPoolTrimTo(pool not None : CUmemoryPool, size_t minBytesToKeep):
    err = ccuda.cuMemPoolTrimTo(pool._ptr[0], minBytesToKeep)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemPoolSetAttribute(pool not None : CUmemoryPool, attr not None : CUmemPool_attribute, value):
    cdef ccuda.CUmemPool_attribute cattr = attr.value
    cdef utils.HelperCUmemPool_attribute cvalue = utils.HelperCUmemPool_attribute(attr, value, is_getter=False)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    err = ccuda.cuMemPoolSetAttribute(pool._ptr[0], cattr, cvalue_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemPoolGetAttribute(pool not None : CUmemoryPool, attr not None : CUmemPool_attribute):
    cdef ccuda.CUmemPool_attribute cattr = attr.value
    cdef utils.HelperCUmemPool_attribute cvalue = utils.HelperCUmemPool_attribute(attr, 0, is_getter=True)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    err = ccuda.cuMemPoolGetAttribute(pool._ptr[0], cattr, cvalue_ptr)
    return (CUresult(err), cvalue.pyObj())

@cython.embedsignature(True)
def cuMemPoolSetAccess(pool not None : CUmemoryPool, map : List[CUmemAccessDesc], size_t count):
    map = [] if map is None else map
    if not all(isinstance(_x, (CUmemAccessDesc)) for _x in map):
        raise TypeError("Argument 'map' is not instance of type (expected List[cudapython.ccuda.CUmemAccessDesc]")
    cdef ccuda.CUmemAccessDesc* cmap = NULL
    if len(map) > 0:
        cmap = <ccuda.CUmemAccessDesc*> calloc(len(map), sizeof(ccuda.CUmemAccessDesc))
        if cmap is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(map)) + 'x' + str(sizeof(ccuda.CUmemAccessDesc)))
        for idx in range(len(map)):
            memcpy(&cmap[idx], (<CUmemAccessDesc>map[idx])._ptr, sizeof(ccuda.CUmemAccessDesc))

    if count > <size_t>len(map): raise RuntimeError("List is too small: " + str(len(map)) + " < " + str(count))
    err = ccuda.cuMemPoolSetAccess(pool._ptr[0], (<CUmemAccessDesc>map[0])._ptr if len(map) == 1 else cmap, count)
    if cmap is not NULL:
        free(cmap)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemPoolGetAccess(memPool not None : CUmemoryPool, location : CUmemLocation):
    cdef ccuda.CUmemAccess_flags flags
    cdef ccuda.CUmemLocation* clocation_ptr = location._ptr if location != None else NULL
    err = ccuda.cuMemPoolGetAccess(&flags, memPool._ptr[0], clocation_ptr)
    return (CUresult(err), CUmemAccess_flags(flags))

@cython.embedsignature(True)
def cuMemPoolCreate(poolProps : CUmemPoolProps):
    cdef CUmemoryPool pool = CUmemoryPool()
    cdef ccuda.CUmemPoolProps* cpoolProps_ptr = poolProps._ptr if poolProps != None else NULL
    err = ccuda.cuMemPoolCreate(pool._ptr, cpoolProps_ptr)
    return (CUresult(err), pool)

@cython.embedsignature(True)
def cuMemPoolDestroy(pool not None : CUmemoryPool):
    err = ccuda.cuMemPoolDestroy(pool._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemAllocFromPoolAsync(size_t bytesize, pool not None : CUmemoryPool, hStream not None : CUstream):
    cdef CUdeviceptr dptr = CUdeviceptr()
    err = ccuda.cuMemAllocFromPoolAsync(dptr._ptr, bytesize, pool._ptr[0], hStream._ptr[0])
    return (CUresult(err), dptr)

@cython.embedsignature(True)
def cuMemPoolExportToShareableHandle(pool not None : CUmemoryPool, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    cdef void_ptr handle_out = 0
    cdef void* chandle_out_ptr = <void*>handle_out
    cdef ccuda.CUmemAllocationHandleType chandleType = handleType.value
    err = ccuda.cuMemPoolExportToShareableHandle(chandle_out_ptr, pool._ptr[0], chandleType, flags)
    return (CUresult(err), handle_out)

@cython.embedsignature(True)
def cuMemPoolImportFromShareableHandle(handle, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    cdef CUmemoryPool pool_out = CUmemoryPool()
    chandle = utils.HelperInputVoidPtr(handle)
    cdef void* chandle_ptr = <void*><void_ptr>chandle.cptr
    cdef ccuda.CUmemAllocationHandleType chandleType = handleType.value
    err = ccuda.cuMemPoolImportFromShareableHandle(pool_out._ptr, chandle_ptr, chandleType, flags)
    return (CUresult(err), pool_out)

@cython.embedsignature(True)
def cuMemPoolExportPointer(ptr not None : CUdeviceptr):
    cdef CUmemPoolPtrExportData shareData_out = CUmemPoolPtrExportData()
    err = ccuda.cuMemPoolExportPointer(shareData_out._ptr, ptr._ptr[0])
    return (CUresult(err), shareData_out)

@cython.embedsignature(True)
def cuMemPoolImportPointer(pool not None : CUmemoryPool, shareData : CUmemPoolPtrExportData):
    cdef CUdeviceptr ptr_out = CUdeviceptr()
    cdef ccuda.CUmemPoolPtrExportData* cshareData_ptr = shareData._ptr if shareData != None else NULL
    err = ccuda.cuMemPoolImportPointer(ptr_out._ptr, pool._ptr[0], cshareData_ptr)
    return (CUresult(err), ptr_out)

@cython.embedsignature(True)
def cuPointerGetAttribute(attribute not None : CUpointer_attribute, ptr not None : CUdeviceptr):
    cdef utils.HelperCUpointer_attribute cdata = utils.HelperCUpointer_attribute(attribute, 0, is_getter=True)
    cdef void* cdata_ptr = <void*><void_ptr>cdata.cptr
    cdef ccuda.CUpointer_attribute cattribute = attribute.value
    err = ccuda.cuPointerGetAttribute(cdata_ptr, cattribute, ptr._ptr[0])
    return (CUresult(err), cdata.pyObj())

@cython.embedsignature(True)
def cuMemPrefetchAsync(devPtr not None : CUdeviceptr, size_t count, dstDevice not None : CUdevice, hStream not None : CUstream):
    err = ccuda.cuMemPrefetchAsync(devPtr._ptr[0], count, dstDevice._ptr[0], hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemAdvise(devPtr not None : CUdeviceptr, size_t count, advice not None : CUmem_advise, device not None : CUdevice):
    cdef ccuda.CUmem_advise cadvice = advice.value
    err = ccuda.cuMemAdvise(devPtr._ptr[0], count, cadvice, device._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemRangeGetAttribute(size_t dataSize, attribute not None : CUmem_range_attribute, devPtr not None : CUdeviceptr, size_t count):
    cdef utils.HelperCUmem_range_attribute cdata = utils.HelperCUmem_range_attribute(attribute, dataSize)
    cdef void* cdata_ptr = <void*><void_ptr>cdata.cptr
    cdef ccuda.CUmem_range_attribute cattribute = attribute.value
    err = ccuda.cuMemRangeGetAttribute(cdata_ptr, dataSize, cattribute, devPtr._ptr[0], count)
    return (CUresult(err), cdata.pyObj())

@cython.embedsignature(True)
def cuMemRangeGetAttributes(dataSizes : List[int], attributes : List[CUmem_range_attribute], size_t numAttributes, devPtr not None : CUdeviceptr, size_t count):
    attributes = [] if attributes is None else attributes
    if not all(isinstance(_x, (CUmem_range_attribute)) for _x in attributes):
        raise TypeError("Argument 'attributes' is not instance of type (expected List[cudapython.ccuda.CUmem_range_attribute]")
    if not all(isinstance(_x, (int)) for _x in dataSizes):
        raise TypeError("Argument 'dataSizes' is not instance of type (expected List[int]")
    pylist = [utils.HelperCUmem_range_attribute(pyattributes, pydataSizes) for (pyattributes, pydataSizes) in zip(attributes, dataSizes)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    cdef void** cvoidStarHelper_ptr = <void**><void_ptr>voidStarHelper.cptr
    cdef vector[size_t] cdataSizes = dataSizes
    cdef vector[ccuda.CUmem_range_attribute] cattributes = [pyattributes.value for pyattributes in (attributes)]
    if numAttributes > <size_t>len(dataSizes): raise RuntimeError("List is too small: " + str(len(dataSizes)) + " < " + str(numAttributes))
    if numAttributes > <size_t>len(attributes): raise RuntimeError("List is too small: " + str(len(attributes)) + " < " + str(numAttributes))
    err = ccuda.cuMemRangeGetAttributes(cvoidStarHelper_ptr, cdataSizes.data(), cattributes.data(), numAttributes, devPtr._ptr[0], count)
    return (CUresult(err), [obj.pyObj() for obj in pylist])

@cython.embedsignature(True)
def cuPointerSetAttribute(value, attribute not None : CUpointer_attribute, ptr not None : CUdeviceptr):
    cdef utils.HelperCUpointer_attribute cvalue = utils.HelperCUpointer_attribute(attribute, value, is_getter=False)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    cdef ccuda.CUpointer_attribute cattribute = attribute.value
    err = ccuda.cuPointerSetAttribute(cvalue_ptr, cattribute, ptr._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuPointerGetAttributes(unsigned int numAttributes, attributes : List[CUpointer_attribute], ptr not None : CUdeviceptr):
    attributes = [] if attributes is None else attributes
    if not all(isinstance(_x, (CUpointer_attribute)) for _x in attributes):
        raise TypeError("Argument 'attributes' is not instance of type (expected List[cudapython.ccuda.CUpointer_attribute]")
    if numAttributes > len(attributes): raise RuntimeError("List is too small: " + str(len(attributes)) + " < " + str(numAttributes))
    cdef vector[ccuda.CUpointer_attribute] cattributes = [pyattributes.value for pyattributes in (attributes)]
    pylist = [utils.HelperCUpointer_attribute(pyattributes, 0, is_getter=True) for pyattributes in attributes]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    cdef void** cvoidStarHelper_ptr = <void**><void_ptr>voidStarHelper.cptr
    err = ccuda.cuPointerGetAttributes(numAttributes, cattributes.data(), cvoidStarHelper_ptr, ptr._ptr[0])
    return (CUresult(err), [obj.pyObj() for obj in pylist])

@cython.embedsignature(True)
def cuStreamCreate(unsigned int Flags):
    cdef CUstream phStream = CUstream()
    err = ccuda.cuStreamCreate(phStream._ptr, Flags)
    return (CUresult(err), phStream)

@cython.embedsignature(True)
def cuStreamCreateWithPriority(unsigned int flags, int priority):
    cdef CUstream phStream = CUstream()
    err = ccuda.cuStreamCreateWithPriority(phStream._ptr, flags, priority)
    return (CUresult(err), phStream)

@cython.embedsignature(True)
def cuStreamGetPriority(hStream not None : CUstream):
    cdef int priority = 0
    err = ccuda.cuStreamGetPriority(hStream._ptr[0], &priority)
    return (CUresult(err), priority)

@cython.embedsignature(True)
def cuStreamGetFlags(hStream not None : CUstream):
    cdef unsigned int flags = 0
    err = ccuda.cuStreamGetFlags(hStream._ptr[0], &flags)
    return (CUresult(err), flags)

@cython.embedsignature(True)
def cuStreamGetCtx(hStream not None : CUstream):
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuStreamGetCtx(hStream._ptr[0], pctx._ptr)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuStreamWaitEvent(hStream not None : CUstream, hEvent not None : CUevent, unsigned int Flags):
    err = ccuda.cuStreamWaitEvent(hStream._ptr[0], hEvent._ptr[0], Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamAddCallback(hStream not None : CUstream, callback not None : CUstreamCallback, userData, unsigned int flags):
    cuserData = utils.HelperInputVoidPtr(userData)
    cdef void* cuserData_ptr = <void*><void_ptr>cuserData.cptr
    err = ccuda.cuStreamAddCallback(hStream._ptr[0], callback._ptr[0], cuserData_ptr, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamBeginCapture(hStream not None : CUstream, mode not None : CUstreamCaptureMode):
    cdef ccuda.CUstreamCaptureMode cmode = mode.value
    err = ccuda.cuStreamBeginCapture(hStream._ptr[0], cmode)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuThreadExchangeStreamCaptureMode(mode not None : CUstreamCaptureMode):
    cdef ccuda.CUstreamCaptureMode cmode = mode.value
    err = ccuda.cuThreadExchangeStreamCaptureMode(&cmode)
    return (CUresult(err), CUstreamCaptureMode(cmode))

@cython.embedsignature(True)
def cuStreamEndCapture(hStream not None : CUstream):
    cdef CUgraph phGraph = CUgraph()
    err = ccuda.cuStreamEndCapture(hStream._ptr[0], phGraph._ptr)
    return (CUresult(err), phGraph)

@cython.embedsignature(True)
def cuStreamIsCapturing(hStream not None : CUstream):
    cdef ccuda.CUstreamCaptureStatus captureStatus
    err = ccuda.cuStreamIsCapturing(hStream._ptr[0], &captureStatus)
    return (CUresult(err), CUstreamCaptureStatus(captureStatus))

@cython.embedsignature(True)
def cuStreamGetCaptureInfo(hStream not None : CUstream):
    cdef ccuda.CUstreamCaptureStatus captureStatus_out
    cdef cuuint64_t id_out = cuuint64_t()
    err = ccuda.cuStreamGetCaptureInfo(hStream._ptr[0], &captureStatus_out, id_out._ptr)
    return (CUresult(err), CUstreamCaptureStatus(captureStatus_out), id_out)

@cython.embedsignature(True)
def cuStreamGetCaptureInfo_v2(hStream not None : CUstream):
    cdef ccuda.CUstreamCaptureStatus captureStatus_out
    cdef cuuint64_t id_out = cuuint64_t()
    cdef CUgraph graph_out = CUgraph()
    cdef const ccuda.CUgraphNode* cdependencies_out = NULL
    pydependencies_out = []
    cdef size_t numDependencies_out = 0
    err = ccuda.cuStreamGetCaptureInfo_v2(hStream._ptr[0], &captureStatus_out, id_out._ptr, graph_out._ptr, &cdependencies_out, &numDependencies_out)
    if CUresult(err) == CUresult(0):
        pydependencies_out = [CUgraphNode(init_value=<void_ptr>cdependencies_out[idx]) for idx in range(numDependencies_out)]
    return (CUresult(err), CUstreamCaptureStatus(captureStatus_out), id_out, graph_out, pydependencies_out, numDependencies_out)

@cython.embedsignature(True)
def cuStreamUpdateCaptureDependencies(hStream not None : CUstream, dependencies : List[CUgraphNode], size_t numDependencies, unsigned int flags):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuStreamUpdateCaptureDependencies(hStream._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, flags)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamAttachMemAsync(hStream not None : CUstream, dptr not None : CUdeviceptr, size_t length, unsigned int flags):
    err = ccuda.cuStreamAttachMemAsync(hStream._ptr[0], dptr._ptr[0], length, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamQuery(hStream not None : CUstream):
    err = ccuda.cuStreamQuery(hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamSynchronize(hStream not None : CUstream):
    err = ccuda.cuStreamSynchronize(hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamDestroy(hStream not None : CUstream):
    err = ccuda.cuStreamDestroy(hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamCopyAttributes(dst not None : CUstream, src not None : CUstream):
    err = ccuda.cuStreamCopyAttributes(dst._ptr[0], src._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamGetAttribute(hStream not None : CUstream, attr not None : CUstreamAttrID):
    cdef ccuda.CUstreamAttrID cattr = attr.value
    cdef CUstreamAttrValue value_out = CUstreamAttrValue()
    err = ccuda.cuStreamGetAttribute(hStream._ptr[0], cattr, value_out._ptr)
    return (CUresult(err), value_out)

@cython.embedsignature(True)
def cuStreamSetAttribute(hStream not None : CUstream, attr not None : CUstreamAttrID, value : CUstreamAttrValue):
    cdef ccuda.CUstreamAttrID cattr = attr.value
    cdef ccuda.CUstreamAttrValue* cvalue_ptr = value._ptr if value != None else NULL
    err = ccuda.cuStreamSetAttribute(hStream._ptr[0], cattr, cvalue_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventCreate(unsigned int Flags):
    cdef CUevent phEvent = CUevent()
    err = ccuda.cuEventCreate(phEvent._ptr, Flags)
    return (CUresult(err), phEvent)

@cython.embedsignature(True)
def cuEventRecord(hEvent not None : CUevent, hStream not None : CUstream):
    err = ccuda.cuEventRecord(hEvent._ptr[0], hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventRecordWithFlags(hEvent not None : CUevent, hStream not None : CUstream, unsigned int flags):
    err = ccuda.cuEventRecordWithFlags(hEvent._ptr[0], hStream._ptr[0], flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventQuery(hEvent not None : CUevent):
    err = ccuda.cuEventQuery(hEvent._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventSynchronize(hEvent not None : CUevent):
    err = ccuda.cuEventSynchronize(hEvent._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventDestroy(hEvent not None : CUevent):
    err = ccuda.cuEventDestroy(hEvent._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventElapsedTime(hStart not None : CUevent, hEnd not None : CUevent):
    cdef float pMilliseconds = 0
    err = ccuda.cuEventElapsedTime(&pMilliseconds, hStart._ptr[0], hEnd._ptr[0])
    return (CUresult(err), pMilliseconds)

@cython.embedsignature(True)
def cuImportExternalMemory(memHandleDesc : CUDA_EXTERNAL_MEMORY_HANDLE_DESC):
    cdef CUexternalMemory extMem_out = CUexternalMemory()
    cdef ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC* cmemHandleDesc_ptr = memHandleDesc._ptr if memHandleDesc != None else NULL
    err = ccuda.cuImportExternalMemory(extMem_out._ptr, cmemHandleDesc_ptr)
    return (CUresult(err), extMem_out)

@cython.embedsignature(True)
def cuExternalMemoryGetMappedBuffer(extMem not None : CUexternalMemory, bufferDesc : CUDA_EXTERNAL_MEMORY_BUFFER_DESC):
    cdef CUdeviceptr devPtr = CUdeviceptr()
    cdef ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC* cbufferDesc_ptr = bufferDesc._ptr if bufferDesc != None else NULL
    err = ccuda.cuExternalMemoryGetMappedBuffer(devPtr._ptr, extMem._ptr[0], cbufferDesc_ptr)
    return (CUresult(err), devPtr)

@cython.embedsignature(True)
def cuExternalMemoryGetMappedMipmappedArray(extMem not None : CUexternalMemory, mipmapDesc : CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC):
    cdef CUmipmappedArray mipmap = CUmipmappedArray()
    cdef ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC* cmipmapDesc_ptr = mipmapDesc._ptr if mipmapDesc != None else NULL
    err = ccuda.cuExternalMemoryGetMappedMipmappedArray(mipmap._ptr, extMem._ptr[0], cmipmapDesc_ptr)
    return (CUresult(err), mipmap)

@cython.embedsignature(True)
def cuDestroyExternalMemory(extMem not None : CUexternalMemory):
    err = ccuda.cuDestroyExternalMemory(extMem._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuImportExternalSemaphore(semHandleDesc : CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC):
    cdef CUexternalSemaphore extSem_out = CUexternalSemaphore()
    cdef ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC* csemHandleDesc_ptr = semHandleDesc._ptr if semHandleDesc != None else NULL
    err = ccuda.cuImportExternalSemaphore(extSem_out._ptr, csemHandleDesc_ptr)
    return (CUresult(err), extSem_out)

@cython.embedsignature(True)
def cuSignalExternalSemaphoresAsync(extSemArray : List[CUexternalSemaphore], paramsArray : List[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS], unsigned int numExtSems, stream not None : CUstream):
    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected List[cudapython.ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS]")
    extSemArray = [] if extSemArray is None else extSemArray
    if not all(isinstance(_x, (CUexternalSemaphore)) for _x in extSemArray):
        raise TypeError("Argument 'extSemArray' is not instance of type (expected List[cudapython.ccuda.CUexternalSemaphore]")
    cdef ccuda.CUexternalSemaphore* cextSemArray = NULL
    if len(extSemArray) > 0:
        cextSemArray = <ccuda.CUexternalSemaphore*> calloc(len(extSemArray), sizeof(ccuda.CUexternalSemaphore))
        if cextSemArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(extSemArray)) + 'x' + str(sizeof(ccuda.CUexternalSemaphore)))
        else:
            for idx in range(len(extSemArray)):
                cextSemArray[idx] = (<CUexternalSemaphore>extSemArray[idx])._ptr[0]

    cdef ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS* cparamsArray = NULL
    if len(paramsArray) > 0:
        cparamsArray = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS*> calloc(len(paramsArray), sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
        if cparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)))
        for idx in range(len(paramsArray)):
            memcpy(&cparamsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>paramsArray[idx])._ptr, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))

    if numExtSems > len(extSemArray): raise RuntimeError("List is too small: " + str(len(extSemArray)) + " < " + str(numExtSems))
    if numExtSems > len(paramsArray): raise RuntimeError("List is too small: " + str(len(paramsArray)) + " < " + str(numExtSems))
    err = ccuda.cuSignalExternalSemaphoresAsync((<CUexternalSemaphore>extSemArray[0])._ptr if len(extSemArray) == 1 else cextSemArray, (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>paramsArray[0])._ptr if len(paramsArray) == 1 else cparamsArray, numExtSems, stream._ptr[0])
    if cextSemArray is not NULL:
        free(cextSemArray)
    if cparamsArray is not NULL:
        free(cparamsArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuWaitExternalSemaphoresAsync(extSemArray : List[CUexternalSemaphore], paramsArray : List[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS], unsigned int numExtSems, stream not None : CUstream):
    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected List[cudapython.ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS]")
    extSemArray = [] if extSemArray is None else extSemArray
    if not all(isinstance(_x, (CUexternalSemaphore)) for _x in extSemArray):
        raise TypeError("Argument 'extSemArray' is not instance of type (expected List[cudapython.ccuda.CUexternalSemaphore]")
    cdef ccuda.CUexternalSemaphore* cextSemArray = NULL
    if len(extSemArray) > 0:
        cextSemArray = <ccuda.CUexternalSemaphore*> calloc(len(extSemArray), sizeof(ccuda.CUexternalSemaphore))
        if cextSemArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(extSemArray)) + 'x' + str(sizeof(ccuda.CUexternalSemaphore)))
        else:
            for idx in range(len(extSemArray)):
                cextSemArray[idx] = (<CUexternalSemaphore>extSemArray[idx])._ptr[0]

    cdef ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS* cparamsArray = NULL
    if len(paramsArray) > 0:
        cparamsArray = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS*> calloc(len(paramsArray), sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
        if cparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)))
        for idx in range(len(paramsArray)):
            memcpy(&cparamsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>paramsArray[idx])._ptr, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))

    if numExtSems > len(extSemArray): raise RuntimeError("List is too small: " + str(len(extSemArray)) + " < " + str(numExtSems))
    if numExtSems > len(paramsArray): raise RuntimeError("List is too small: " + str(len(paramsArray)) + " < " + str(numExtSems))
    err = ccuda.cuWaitExternalSemaphoresAsync((<CUexternalSemaphore>extSemArray[0])._ptr if len(extSemArray) == 1 else cextSemArray, (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>paramsArray[0])._ptr if len(paramsArray) == 1 else cparamsArray, numExtSems, stream._ptr[0])
    if cextSemArray is not NULL:
        free(cextSemArray)
    if cparamsArray is not NULL:
        free(cparamsArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDestroyExternalSemaphore(extSem not None : CUexternalSemaphore):
    err = ccuda.cuDestroyExternalSemaphore(extSem._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWaitValue32(stream not None : CUstream, addr not None : CUdeviceptr, value not None : cuuint32_t, unsigned int flags):
    err = ccuda.cuStreamWaitValue32(stream._ptr[0], addr._ptr[0], value._ptr[0], flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWaitValue64(stream not None : CUstream, addr not None : CUdeviceptr, value not None : cuuint64_t, unsigned int flags):
    err = ccuda.cuStreamWaitValue64(stream._ptr[0], addr._ptr[0], value._ptr[0], flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWriteValue32(stream not None : CUstream, addr not None : CUdeviceptr, value not None : cuuint32_t, unsigned int flags):
    err = ccuda.cuStreamWriteValue32(stream._ptr[0], addr._ptr[0], value._ptr[0], flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWriteValue64(stream not None : CUstream, addr not None : CUdeviceptr, value not None : cuuint64_t, unsigned int flags):
    err = ccuda.cuStreamWriteValue64(stream._ptr[0], addr._ptr[0], value._ptr[0], flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamBatchMemOp(stream not None : CUstream, unsigned int count, paramArray : List[CUstreamBatchMemOpParams], unsigned int flags):
    paramArray = [] if paramArray is None else paramArray
    if not all(isinstance(_x, (CUstreamBatchMemOpParams)) for _x in paramArray):
        raise TypeError("Argument 'paramArray' is not instance of type (expected List[cudapython.ccuda.CUstreamBatchMemOpParams]")
    if count > len(paramArray): raise RuntimeError("List is too small: " + str(len(paramArray)) + " < " + str(count))
    cdef ccuda.CUstreamBatchMemOpParams* cparamArray = NULL
    if len(paramArray) > 0:
        cparamArray = <ccuda.CUstreamBatchMemOpParams*> calloc(len(paramArray), sizeof(ccuda.CUstreamBatchMemOpParams))
        if cparamArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramArray)) + 'x' + str(sizeof(ccuda.CUstreamBatchMemOpParams)))
        for idx in range(len(paramArray)):
            memcpy(&cparamArray[idx], (<CUstreamBatchMemOpParams>paramArray[idx])._ptr, sizeof(ccuda.CUstreamBatchMemOpParams))

    err = ccuda.cuStreamBatchMemOp(stream._ptr[0], count, (<CUstreamBatchMemOpParams>paramArray[0])._ptr if len(paramArray) == 1 else cparamArray, flags)
    if cparamArray is not NULL:
        free(cparamArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncGetAttribute(attrib not None : CUfunction_attribute, hfunc not None : CUfunction):
    cdef int pi = 0
    cdef ccuda.CUfunction_attribute cattrib = attrib.value
    err = ccuda.cuFuncGetAttribute(&pi, cattrib, hfunc._ptr[0])
    return (CUresult(err), pi)

@cython.embedsignature(True)
def cuFuncSetAttribute(hfunc not None : CUfunction, attrib not None : CUfunction_attribute, int value):
    cdef ccuda.CUfunction_attribute cattrib = attrib.value
    err = ccuda.cuFuncSetAttribute(hfunc._ptr[0], cattrib, value)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncSetCacheConfig(hfunc not None : CUfunction, config not None : CUfunc_cache):
    cdef ccuda.CUfunc_cache cconfig = config.value
    err = ccuda.cuFuncSetCacheConfig(hfunc._ptr[0], cconfig)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncSetSharedMemConfig(hfunc not None : CUfunction, config not None : CUsharedconfig):
    cdef ccuda.CUsharedconfig cconfig = config.value
    err = ccuda.cuFuncSetSharedMemConfig(hfunc._ptr[0], cconfig)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncGetModule(hfunc not None : CUfunction):
    cdef CUmodule hmod = CUmodule()
    err = ccuda.cuFuncGetModule(hmod._ptr, hfunc._ptr[0])
    return (CUresult(err), hmod)

@cython.embedsignature(True)
def cuLaunchKernel(f not None : CUfunction, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hStream not None : CUstream, kernelParams, void_ptr extra):
    ckernelParams = utils.HelperKernelParams(kernelParams)
    err = ccuda.cuLaunchKernel(f._ptr[0], gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream._ptr[0], <void**><void_ptr>ckernelParams.ckernelParams, <void**>extra)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchCooperativeKernel(f not None : CUfunction, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hStream not None : CUstream, kernelParams):
    ckernelParams = utils.HelperKernelParams(kernelParams)
    err = ccuda.cuLaunchCooperativeKernel(f._ptr[0], gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream._ptr[0], <void**><void_ptr>ckernelParams.ckernelParams)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchCooperativeKernelMultiDevice(launchParamsList : List[CUDA_LAUNCH_PARAMS], unsigned int numDevices, unsigned int flags):
    launchParamsList = [] if launchParamsList is None else launchParamsList
    if not all(isinstance(_x, (CUDA_LAUNCH_PARAMS)) for _x in launchParamsList):
        raise TypeError("Argument 'launchParamsList' is not instance of type (expected List[cudapython.ccuda.CUDA_LAUNCH_PARAMS]")
    cdef ccuda.CUDA_LAUNCH_PARAMS* claunchParamsList = NULL
    if len(launchParamsList) > 0:
        claunchParamsList = <ccuda.CUDA_LAUNCH_PARAMS*> calloc(len(launchParamsList), sizeof(ccuda.CUDA_LAUNCH_PARAMS))
        if claunchParamsList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(launchParamsList)) + 'x' + str(sizeof(ccuda.CUDA_LAUNCH_PARAMS)))
        for idx in range(len(launchParamsList)):
            memcpy(&claunchParamsList[idx], (<CUDA_LAUNCH_PARAMS>launchParamsList[idx])._ptr, sizeof(ccuda.CUDA_LAUNCH_PARAMS))

    if numDevices > len(launchParamsList): raise RuntimeError("List is too small: " + str(len(launchParamsList)) + " < " + str(numDevices))
    err = ccuda.cuLaunchCooperativeKernelMultiDevice((<CUDA_LAUNCH_PARAMS>launchParamsList[0])._ptr if len(launchParamsList) == 1 else claunchParamsList, numDevices, flags)
    if claunchParamsList is not NULL:
        free(claunchParamsList)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchHostFunc(hStream not None : CUstream, fn not None : CUhostFn, userData):
    cuserData = utils.HelperInputVoidPtr(userData)
    cdef void* cuserData_ptr = <void*><void_ptr>cuserData.cptr
    err = ccuda.cuLaunchHostFunc(hStream._ptr[0], fn._ptr[0], cuserData_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncSetBlockShape(hfunc not None : CUfunction, int x, int y, int z):
    err = ccuda.cuFuncSetBlockShape(hfunc._ptr[0], x, y, z)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncSetSharedSize(hfunc not None : CUfunction, unsigned int numbytes):
    err = ccuda.cuFuncSetSharedSize(hfunc._ptr[0], numbytes)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSetSize(hfunc not None : CUfunction, unsigned int numbytes):
    err = ccuda.cuParamSetSize(hfunc._ptr[0], numbytes)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSeti(hfunc not None : CUfunction, int offset, unsigned int value):
    err = ccuda.cuParamSeti(hfunc._ptr[0], offset, value)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSetf(hfunc not None : CUfunction, int offset, float value):
    err = ccuda.cuParamSetf(hfunc._ptr[0], offset, value)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSetv(hfunc not None : CUfunction, int offset, ptr, unsigned int numbytes):
    cptr = utils.HelperInputVoidPtr(ptr)
    cdef void* cptr_ptr = <void*><void_ptr>cptr.cptr
    err = ccuda.cuParamSetv(hfunc._ptr[0], offset, cptr_ptr, numbytes)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunch(f not None : CUfunction):
    err = ccuda.cuLaunch(f._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchGrid(f not None : CUfunction, int grid_width, int grid_height):
    err = ccuda.cuLaunchGrid(f._ptr[0], grid_width, grid_height)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchGridAsync(f not None : CUfunction, int grid_width, int grid_height, hStream not None : CUstream):
    err = ccuda.cuLaunchGridAsync(f._ptr[0], grid_width, grid_height, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSetTexRef(hfunc not None : CUfunction, int texunit, hTexRef not None : CUtexref):
    err = ccuda.cuParamSetTexRef(hfunc._ptr[0], texunit, hTexRef._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphCreate(unsigned int flags):
    cdef CUgraph phGraph = CUgraph()
    err = ccuda.cuGraphCreate(phGraph._ptr, flags)
    return (CUresult(err), phGraph)

@cython.embedsignature(True)
def cuGraphAddKernelNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_KERNEL_NODE_PARAMS):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_KERNEL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddKernelNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphKernelNodeGetParams(hNode not None : CUgraphNode):
    cdef CUDA_KERNEL_NODE_PARAMS nodeParams = CUDA_KERNEL_NODE_PARAMS()
    err = ccuda.cuGraphKernelNodeGetParams(hNode._ptr[0], nodeParams._ptr)
    return (CUresult(err), nodeParams)

@cython.embedsignature(True)
def cuGraphKernelNodeSetParams(hNode not None : CUgraphNode, nodeParams : CUDA_KERNEL_NODE_PARAMS):
    cdef ccuda.CUDA_KERNEL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphKernelNodeSetParams(hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddMemcpyNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, copyParams : CUDA_MEMCPY3D, ctx not None : CUcontext):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_MEMCPY3D* ccopyParams_ptr = copyParams._ptr if copyParams != None else NULL
    err = ccuda.cuGraphAddMemcpyNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, ccopyParams_ptr, ctx._ptr[0])
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphMemcpyNodeGetParams(hNode not None : CUgraphNode):
    cdef CUDA_MEMCPY3D nodeParams = CUDA_MEMCPY3D()
    err = ccuda.cuGraphMemcpyNodeGetParams(hNode._ptr[0], nodeParams._ptr)
    return (CUresult(err), nodeParams)

@cython.embedsignature(True)
def cuGraphMemcpyNodeSetParams(hNode not None : CUgraphNode, nodeParams : CUDA_MEMCPY3D):
    cdef ccuda.CUDA_MEMCPY3D* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphMemcpyNodeSetParams(hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddMemsetNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, memsetParams : CUDA_MEMSET_NODE_PARAMS, ctx not None : CUcontext):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_MEMSET_NODE_PARAMS* cmemsetParams_ptr = memsetParams._ptr if memsetParams != None else NULL
    err = ccuda.cuGraphAddMemsetNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cmemsetParams_ptr, ctx._ptr[0])
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphMemsetNodeGetParams(hNode not None : CUgraphNode):
    cdef CUDA_MEMSET_NODE_PARAMS nodeParams = CUDA_MEMSET_NODE_PARAMS()
    err = ccuda.cuGraphMemsetNodeGetParams(hNode._ptr[0], nodeParams._ptr)
    return (CUresult(err), nodeParams)

@cython.embedsignature(True)
def cuGraphMemsetNodeSetParams(hNode not None : CUgraphNode, nodeParams : CUDA_MEMSET_NODE_PARAMS):
    cdef ccuda.CUDA_MEMSET_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphMemsetNodeSetParams(hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddHostNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_HOST_NODE_PARAMS):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_HOST_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddHostNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphHostNodeGetParams(hNode not None : CUgraphNode):
    cdef CUDA_HOST_NODE_PARAMS nodeParams = CUDA_HOST_NODE_PARAMS()
    err = ccuda.cuGraphHostNodeGetParams(hNode._ptr[0], nodeParams._ptr)
    return (CUresult(err), nodeParams)

@cython.embedsignature(True)
def cuGraphHostNodeSetParams(hNode not None : CUgraphNode, nodeParams : CUDA_HOST_NODE_PARAMS):
    cdef ccuda.CUDA_HOST_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphHostNodeSetParams(hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddChildGraphNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, childGraph not None : CUgraph):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddChildGraphNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, childGraph._ptr[0])
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphChildGraphNodeGetGraph(hNode not None : CUgraphNode):
    cdef CUgraph phGraph = CUgraph()
    err = ccuda.cuGraphChildGraphNodeGetGraph(hNode._ptr[0], phGraph._ptr)
    return (CUresult(err), phGraph)

@cython.embedsignature(True)
def cuGraphAddEmptyNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddEmptyNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphAddEventRecordNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, event not None : CUevent):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddEventRecordNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, event._ptr[0])
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphEventRecordNodeGetEvent(hNode not None : CUgraphNode):
    cdef CUevent event_out = CUevent()
    err = ccuda.cuGraphEventRecordNodeGetEvent(hNode._ptr[0], event_out._ptr)
    return (CUresult(err), event_out)

@cython.embedsignature(True)
def cuGraphEventRecordNodeSetEvent(hNode not None : CUgraphNode, event not None : CUevent):
    err = ccuda.cuGraphEventRecordNodeSetEvent(hNode._ptr[0], event._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddEventWaitNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, event not None : CUevent):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddEventWaitNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, event._ptr[0])
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphEventWaitNodeGetEvent(hNode not None : CUgraphNode):
    cdef CUevent event_out = CUevent()
    err = ccuda.cuGraphEventWaitNodeGetEvent(hNode._ptr[0], event_out._ptr)
    return (CUresult(err), event_out)

@cython.embedsignature(True)
def cuGraphEventWaitNodeSetEvent(hNode not None : CUgraphNode, event not None : CUevent):
    err = ccuda.cuGraphEventWaitNodeSetEvent(hNode._ptr[0], event._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddExternalSemaphoresSignalNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_EXT_SEM_SIGNAL_NODE_PARAMS):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddExternalSemaphoresSignalNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphExternalSemaphoresSignalNodeGetParams(hNode not None : CUgraphNode):
    cdef CUDA_EXT_SEM_SIGNAL_NODE_PARAMS params_out = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS()
    err = ccuda.cuGraphExternalSemaphoresSignalNodeGetParams(hNode._ptr[0], params_out._ptr)
    return (CUresult(err), params_out)

@cython.embedsignature(True)
def cuGraphExternalSemaphoresSignalNodeSetParams(hNode not None : CUgraphNode, nodeParams : CUDA_EXT_SEM_SIGNAL_NODE_PARAMS):
    cdef ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExternalSemaphoresSignalNodeSetParams(hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddExternalSemaphoresWaitNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_EXT_SEM_WAIT_NODE_PARAMS):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddExternalSemaphoresWaitNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphExternalSemaphoresWaitNodeGetParams(hNode not None : CUgraphNode):
    cdef CUDA_EXT_SEM_WAIT_NODE_PARAMS params_out = CUDA_EXT_SEM_WAIT_NODE_PARAMS()
    err = ccuda.cuGraphExternalSemaphoresWaitNodeGetParams(hNode._ptr[0], params_out._ptr)
    return (CUresult(err), params_out)

@cython.embedsignature(True)
def cuGraphExternalSemaphoresWaitNodeSetParams(hNode not None : CUgraphNode, nodeParams : CUDA_EXT_SEM_WAIT_NODE_PARAMS):
    cdef ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExternalSemaphoresWaitNodeSetParams(hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddMemAllocNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_MEM_ALLOC_NODE_PARAMS):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_MEM_ALLOC_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddMemAllocNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphMemAllocNodeGetParams(hNode not None : CUgraphNode):
    cdef CUDA_MEM_ALLOC_NODE_PARAMS params_out = CUDA_MEM_ALLOC_NODE_PARAMS()
    err = ccuda.cuGraphMemAllocNodeGetParams(hNode._ptr[0], params_out._ptr)
    return (CUresult(err), params_out)

@cython.embedsignature(True)
def cuGraphAddMemFreeNode(hGraph not None : CUgraph, dependencies : List[CUgraphNode], size_t numDependencies, dptr not None : CUdeviceptr):
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddMemFreeNode(phGraphNode._ptr, hGraph._ptr[0], (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, dptr._ptr[0])
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphMemFreeNodeGetParams(hNode not None : CUgraphNode):
    cdef CUdeviceptr dptr_out = CUdeviceptr()
    err = ccuda.cuGraphMemFreeNodeGetParams(hNode._ptr[0], dptr_out._ptr)
    return (CUresult(err), dptr_out)

@cython.embedsignature(True)
def cuDeviceGraphMemTrim(device not None : CUdevice):
    err = ccuda.cuDeviceGraphMemTrim(device._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetGraphMemAttribute(device not None : CUdevice, attr not None : CUgraphMem_attribute):
    cdef ccuda.CUgraphMem_attribute cattr = attr.value
    cdef utils.HelperCUgraphMem_attribute cvalue = utils.HelperCUgraphMem_attribute(attr, 0, is_getter=True)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    err = ccuda.cuDeviceGetGraphMemAttribute(device._ptr[0], cattr, cvalue_ptr)
    return (CUresult(err), cvalue.pyObj())

@cython.embedsignature(True)
def cuDeviceSetGraphMemAttribute(device not None : CUdevice, attr not None : CUgraphMem_attribute, value):
    cdef ccuda.CUgraphMem_attribute cattr = attr.value
    cdef utils.HelperCUgraphMem_attribute cvalue = utils.HelperCUgraphMem_attribute(attr, value, is_getter=False)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    err = ccuda.cuDeviceSetGraphMemAttribute(device._ptr[0], cattr, cvalue_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphClone(originalGraph not None : CUgraph):
    cdef CUgraph phGraphClone = CUgraph()
    err = ccuda.cuGraphClone(phGraphClone._ptr, originalGraph._ptr[0])
    return (CUresult(err), phGraphClone)

@cython.embedsignature(True)
def cuGraphNodeFindInClone(hOriginalNode not None : CUgraphNode, hClonedGraph not None : CUgraph):
    cdef CUgraphNode phNode = CUgraphNode()
    err = ccuda.cuGraphNodeFindInClone(phNode._ptr, hOriginalNode._ptr[0], hClonedGraph._ptr[0])
    return (CUresult(err), phNode)

@cython.embedsignature(True)
def cuGraphNodeGetType(hNode not None : CUgraphNode):
    cdef ccuda.CUgraphNodeType typename
    err = ccuda.cuGraphNodeGetType(hNode._ptr[0], &typename)
    return (CUresult(err), CUgraphNodeType(typename))

@cython.embedsignature(True)
def cuGraphGetNodes(hGraph not None : CUgraph, size_t numNodes = 0):
    cdef size_t _graph_length = numNodes
    cdef ccuda.CUgraphNode* cnodes = NULL
    pynodes = []
    if _graph_length != 0:
        cnodes = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cnodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphGetNodes(hGraph._ptr[0], cnodes, &numNodes)
    if CUresult(err) == CUresult(0):
        pynodes = [CUgraphNode(init_value=<void_ptr>cnodes[idx]) for idx in range(_graph_length)]
    if cnodes is not NULL:
        free(cnodes)
    return (CUresult(err), pynodes, numNodes)

@cython.embedsignature(True)
def cuGraphGetRootNodes(hGraph not None : CUgraph, size_t numRootNodes = 0):
    cdef size_t _graph_length = numRootNodes
    cdef ccuda.CUgraphNode* crootNodes = NULL
    pyrootNodes = []
    if _graph_length != 0:
        crootNodes = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if crootNodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphGetRootNodes(hGraph._ptr[0], crootNodes, &numRootNodes)
    if CUresult(err) == CUresult(0):
        pyrootNodes = [CUgraphNode(init_value=<void_ptr>crootNodes[idx]) for idx in range(_graph_length)]
    if crootNodes is not NULL:
        free(crootNodes)
    return (CUresult(err), pyrootNodes, numRootNodes)

@cython.embedsignature(True)
def cuGraphGetEdges(hGraph not None : CUgraph, size_t numEdges = 0):
    cdef size_t _graph_length = numEdges
    cdef ccuda.CUgraphNode* cfrom_ = NULL
    pyfrom_ = []
    if _graph_length != 0:
        cfrom_ = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    cdef ccuda.CUgraphNode* cto = NULL
    pyto = []
    if _graph_length != 0:
        cto = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphGetEdges(hGraph._ptr[0], cfrom_, cto, &numEdges)
    if CUresult(err) == CUresult(0):
        pyfrom_ = [CUgraphNode(init_value=<void_ptr>cfrom_[idx]) for idx in range(_graph_length)]
    if cfrom_ is not NULL:
        free(cfrom_)
    if CUresult(err) == CUresult(0):
        pyto = [CUgraphNode(init_value=<void_ptr>cto[idx]) for idx in range(_graph_length)]
    if cto is not NULL:
        free(cto)
    return (CUresult(err), pyfrom_, pyto, numEdges)

@cython.embedsignature(True)
def cuGraphNodeGetDependencies(hNode not None : CUgraphNode, size_t numDependencies = 0):
    cdef size_t _graph_length = numDependencies
    cdef ccuda.CUgraphNode* cdependencies = NULL
    pydependencies = []
    if _graph_length != 0:
        cdependencies = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphNodeGetDependencies(hNode._ptr[0], cdependencies, &numDependencies)
    if CUresult(err) == CUresult(0):
        pydependencies = [CUgraphNode(init_value=<void_ptr>cdependencies[idx]) for idx in range(_graph_length)]
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), pydependencies, numDependencies)

@cython.embedsignature(True)
def cuGraphNodeGetDependentNodes(hNode not None : CUgraphNode, size_t numDependentNodes = 0):
    cdef size_t _graph_length = numDependentNodes
    cdef ccuda.CUgraphNode* cdependentNodes = NULL
    pydependentNodes = []
    if _graph_length != 0:
        cdependentNodes = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cdependentNodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphNodeGetDependentNodes(hNode._ptr[0], cdependentNodes, &numDependentNodes)
    if CUresult(err) == CUresult(0):
        pydependentNodes = [CUgraphNode(init_value=<void_ptr>cdependentNodes[idx]) for idx in range(_graph_length)]
    if cdependentNodes is not NULL:
        free(cdependentNodes)
    return (CUresult(err), pydependentNodes, numDependentNodes)

@cython.embedsignature(True)
def cuGraphAddDependencies(hGraph not None : CUgraph, from_ : List[CUgraphNode], to : List[CUgraphNode], size_t numDependencies):
    to = [] if to is None else to
    if not all(isinstance(_x, (CUgraphNode)) for _x in to):
        raise TypeError("Argument 'to' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    from_ = [] if from_ is None else from_
    if not all(isinstance(_x, (CUgraphNode)) for _x in from_):
        raise TypeError("Argument 'from_' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef ccuda.CUgraphNode* cfrom_ = NULL
    if len(from_) > 0:
        cfrom_ = <ccuda.CUgraphNode*> calloc(len(from_), sizeof(ccuda.CUgraphNode))
        if cfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(from_)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(from_)):
                cfrom_[idx] = (<CUgraphNode>from_[idx])._ptr[0]

    cdef ccuda.CUgraphNode* cto = NULL
    if len(to) > 0:
        cto = <ccuda.CUgraphNode*> calloc(len(to), sizeof(ccuda.CUgraphNode))
        if cto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(to)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(to)):
                cto[idx] = (<CUgraphNode>to[idx])._ptr[0]

    err = ccuda.cuGraphAddDependencies(hGraph._ptr[0], (<CUgraphNode>from_[0])._ptr if len(from_) == 1 else cfrom_, (<CUgraphNode>to[0])._ptr if len(to) == 1 else cto, numDependencies)
    if cfrom_ is not NULL:
        free(cfrom_)
    if cto is not NULL:
        free(cto)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphRemoveDependencies(hGraph not None : CUgraph, from_ : List[CUgraphNode], to : List[CUgraphNode], size_t numDependencies):
    to = [] if to is None else to
    if not all(isinstance(_x, (CUgraphNode)) for _x in to):
        raise TypeError("Argument 'to' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    from_ = [] if from_ is None else from_
    if not all(isinstance(_x, (CUgraphNode)) for _x in from_):
        raise TypeError("Argument 'from_' is not instance of type (expected List[cudapython.ccuda.CUgraphNode]")
    cdef ccuda.CUgraphNode* cfrom_ = NULL
    if len(from_) > 0:
        cfrom_ = <ccuda.CUgraphNode*> calloc(len(from_), sizeof(ccuda.CUgraphNode))
        if cfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(from_)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(from_)):
                cfrom_[idx] = (<CUgraphNode>from_[idx])._ptr[0]

    cdef ccuda.CUgraphNode* cto = NULL
    if len(to) > 0:
        cto = <ccuda.CUgraphNode*> calloc(len(to), sizeof(ccuda.CUgraphNode))
        if cto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(to)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(to)):
                cto[idx] = (<CUgraphNode>to[idx])._ptr[0]

    err = ccuda.cuGraphRemoveDependencies(hGraph._ptr[0], (<CUgraphNode>from_[0])._ptr if len(from_) == 1 else cfrom_, (<CUgraphNode>to[0])._ptr if len(to) == 1 else cto, numDependencies)
    if cfrom_ is not NULL:
        free(cfrom_)
    if cto is not NULL:
        free(cto)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphDestroyNode(hNode not None : CUgraphNode):
    err = ccuda.cuGraphDestroyNode(hNode._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphInstantiate(hGraph not None : CUgraph, char* logBuffer, size_t bufferSize):
    cdef CUgraphExec phGraphExec = CUgraphExec()
    cdef CUgraphNode phErrorNode = CUgraphNode()
    err = ccuda.cuGraphInstantiate(phGraphExec._ptr, hGraph._ptr[0], phErrorNode._ptr, logBuffer, bufferSize)
    return (CUresult(err), phGraphExec, phErrorNode)

@cython.embedsignature(True)
def cuGraphInstantiateWithFlags(hGraph not None : CUgraph, unsigned long long flags):
    cdef CUgraphExec phGraphExec = CUgraphExec()
    err = ccuda.cuGraphInstantiateWithFlags(phGraphExec._ptr, hGraph._ptr[0], flags)
    return (CUresult(err), phGraphExec)

@cython.embedsignature(True)
def cuGraphExecKernelNodeSetParams(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, nodeParams : CUDA_KERNEL_NODE_PARAMS):
    cdef ccuda.CUDA_KERNEL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecKernelNodeSetParams(hGraphExec._ptr[0], hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecMemcpyNodeSetParams(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, copyParams : CUDA_MEMCPY3D, ctx not None : CUcontext):
    cdef ccuda.CUDA_MEMCPY3D* ccopyParams_ptr = copyParams._ptr if copyParams != None else NULL
    err = ccuda.cuGraphExecMemcpyNodeSetParams(hGraphExec._ptr[0], hNode._ptr[0], ccopyParams_ptr, ctx._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecMemsetNodeSetParams(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, memsetParams : CUDA_MEMSET_NODE_PARAMS, ctx not None : CUcontext):
    cdef ccuda.CUDA_MEMSET_NODE_PARAMS* cmemsetParams_ptr = memsetParams._ptr if memsetParams != None else NULL
    err = ccuda.cuGraphExecMemsetNodeSetParams(hGraphExec._ptr[0], hNode._ptr[0], cmemsetParams_ptr, ctx._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecHostNodeSetParams(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, nodeParams : CUDA_HOST_NODE_PARAMS):
    cdef ccuda.CUDA_HOST_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecHostNodeSetParams(hGraphExec._ptr[0], hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecChildGraphNodeSetParams(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, childGraph not None : CUgraph):
    err = ccuda.cuGraphExecChildGraphNodeSetParams(hGraphExec._ptr[0], hNode._ptr[0], childGraph._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecEventRecordNodeSetEvent(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, event not None : CUevent):
    err = ccuda.cuGraphExecEventRecordNodeSetEvent(hGraphExec._ptr[0], hNode._ptr[0], event._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecEventWaitNodeSetEvent(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, event not None : CUevent):
    err = ccuda.cuGraphExecEventWaitNodeSetEvent(hGraphExec._ptr[0], hNode._ptr[0], event._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, nodeParams : CUDA_EXT_SEM_SIGNAL_NODE_PARAMS):
    cdef ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec._ptr[0], hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec not None : CUgraphExec, hNode not None : CUgraphNode, nodeParams : CUDA_EXT_SEM_WAIT_NODE_PARAMS):
    cdef ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec._ptr[0], hNode._ptr[0], cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphUpload(hGraphExec not None : CUgraphExec, hStream not None : CUstream):
    err = ccuda.cuGraphUpload(hGraphExec._ptr[0], hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphLaunch(hGraphExec not None : CUgraphExec, hStream not None : CUstream):
    err = ccuda.cuGraphLaunch(hGraphExec._ptr[0], hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecDestroy(hGraphExec not None : CUgraphExec):
    err = ccuda.cuGraphExecDestroy(hGraphExec._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphDestroy(hGraph not None : CUgraph):
    err = ccuda.cuGraphDestroy(hGraph._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecUpdate(hGraphExec not None : CUgraphExec, hGraph not None : CUgraph):
    cdef CUgraphNode hErrorNode_out = CUgraphNode()
    cdef ccuda.CUgraphExecUpdateResult updateResult_out
    err = ccuda.cuGraphExecUpdate(hGraphExec._ptr[0], hGraph._ptr[0], hErrorNode_out._ptr, &updateResult_out)
    return (CUresult(err), hErrorNode_out, CUgraphExecUpdateResult(updateResult_out))

@cython.embedsignature(True)
def cuGraphKernelNodeCopyAttributes(dst not None : CUgraphNode, src not None : CUgraphNode):
    err = ccuda.cuGraphKernelNodeCopyAttributes(dst._ptr[0], src._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphKernelNodeGetAttribute(hNode not None : CUgraphNode, attr not None : CUkernelNodeAttrID):
    cdef ccuda.CUkernelNodeAttrID cattr = attr.value
    cdef CUkernelNodeAttrValue value_out = CUkernelNodeAttrValue()
    err = ccuda.cuGraphKernelNodeGetAttribute(hNode._ptr[0], cattr, value_out._ptr)
    return (CUresult(err), value_out)

@cython.embedsignature(True)
def cuGraphKernelNodeSetAttribute(hNode not None : CUgraphNode, attr not None : CUkernelNodeAttrID, value : CUkernelNodeAttrValue):
    cdef ccuda.CUkernelNodeAttrID cattr = attr.value
    cdef ccuda.CUkernelNodeAttrValue* cvalue_ptr = value._ptr if value != None else NULL
    err = ccuda.cuGraphKernelNodeSetAttribute(hNode._ptr[0], cattr, cvalue_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphDebugDotPrint(hGraph not None : CUgraph, char* path, unsigned int flags):
    err = ccuda.cuGraphDebugDotPrint(hGraph._ptr[0], path, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuUserObjectCreate(ptr, destroy not None : CUhostFn, unsigned int initialRefcount, unsigned int flags):
    cdef CUuserObject object_out = CUuserObject()
    cptr = utils.HelperInputVoidPtr(ptr)
    cdef void* cptr_ptr = <void*><void_ptr>cptr.cptr
    err = ccuda.cuUserObjectCreate(object_out._ptr, cptr_ptr, destroy._ptr[0], initialRefcount, flags)
    return (CUresult(err), object_out)

@cython.embedsignature(True)
def cuUserObjectRetain(object not None : CUuserObject, unsigned int count):
    err = ccuda.cuUserObjectRetain(object._ptr[0], count)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuUserObjectRelease(object not None : CUuserObject, unsigned int count):
    err = ccuda.cuUserObjectRelease(object._ptr[0], count)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphRetainUserObject(graph not None : CUgraph, object not None : CUuserObject, unsigned int count, unsigned int flags):
    err = ccuda.cuGraphRetainUserObject(graph._ptr[0], object._ptr[0], count, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphReleaseUserObject(graph not None : CUgraph, object not None : CUuserObject, unsigned int count):
    err = ccuda.cuGraphReleaseUserObject(graph._ptr[0], object._ptr[0], count)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuOccupancyMaxActiveBlocksPerMultiprocessor(func not None : CUfunction, int blockSize, size_t dynamicSMemSize):
    cdef int numBlocks = 0
    err = ccuda.cuOccupancyMaxActiveBlocksPerMultiprocessor(&numBlocks, func._ptr[0], blockSize, dynamicSMemSize)
    return (CUresult(err), numBlocks)

@cython.embedsignature(True)
def cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(func not None : CUfunction, int blockSize, size_t dynamicSMemSize, unsigned int flags):
    cdef int numBlocks = 0
    err = ccuda.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&numBlocks, func._ptr[0], blockSize, dynamicSMemSize, flags)
    return (CUresult(err), numBlocks)

@cython.embedsignature(True)
def cuOccupancyMaxPotentialBlockSize(func not None : CUfunction, blockSizeToDynamicSMemSize not None : CUoccupancyB2DSize, size_t dynamicSMemSize, int blockSizeLimit):
    cdef int minGridSize = 0
    cdef int blockSize = 0
    err = ccuda.cuOccupancyMaxPotentialBlockSize(&minGridSize, &blockSize, func._ptr[0], blockSizeToDynamicSMemSize._ptr[0], dynamicSMemSize, blockSizeLimit)
    return (CUresult(err), minGridSize, blockSize)

@cython.embedsignature(True)
def cuOccupancyMaxPotentialBlockSizeWithFlags(func not None : CUfunction, blockSizeToDynamicSMemSize not None : CUoccupancyB2DSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned int flags):
    cdef int minGridSize = 0
    cdef int blockSize = 0
    err = ccuda.cuOccupancyMaxPotentialBlockSizeWithFlags(&minGridSize, &blockSize, func._ptr[0], blockSizeToDynamicSMemSize._ptr[0], dynamicSMemSize, blockSizeLimit, flags)
    return (CUresult(err), minGridSize, blockSize)

@cython.embedsignature(True)
def cuOccupancyAvailableDynamicSMemPerBlock(func not None : CUfunction, int numBlocks, int blockSize):
    cdef size_t dynamicSmemSize = 0
    err = ccuda.cuOccupancyAvailableDynamicSMemPerBlock(&dynamicSmemSize, func._ptr[0], numBlocks, blockSize)
    return (CUresult(err), dynamicSmemSize)

@cython.embedsignature(True)
def cuTexRefSetArray(hTexRef not None : CUtexref, hArray not None : CUarray, unsigned int Flags):
    err = ccuda.cuTexRefSetArray(hTexRef._ptr[0], hArray._ptr[0], Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMipmappedArray(hTexRef not None : CUtexref, hMipmappedArray not None : CUmipmappedArray, unsigned int Flags):
    err = ccuda.cuTexRefSetMipmappedArray(hTexRef._ptr[0], hMipmappedArray._ptr[0], Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetAddress(hTexRef not None : CUtexref, dptr not None : CUdeviceptr, size_t numbytes):
    cdef size_t ByteOffset = 0
    err = ccuda.cuTexRefSetAddress(&ByteOffset, hTexRef._ptr[0], dptr._ptr[0], numbytes)
    return (CUresult(err), ByteOffset)

@cython.embedsignature(True)
def cuTexRefSetAddress2D(hTexRef not None : CUtexref, desc : CUDA_ARRAY_DESCRIPTOR, dptr not None : CUdeviceptr, size_t Pitch):
    cdef ccuda.CUDA_ARRAY_DESCRIPTOR* cdesc_ptr = desc._ptr if desc != None else NULL
    err = ccuda.cuTexRefSetAddress2D(hTexRef._ptr[0], cdesc_ptr, dptr._ptr[0], Pitch)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetFormat(hTexRef not None : CUtexref, fmt not None : CUarray_format, int NumPackedComponents):
    cdef ccuda.CUarray_format cfmt = fmt.value
    err = ccuda.cuTexRefSetFormat(hTexRef._ptr[0], cfmt, NumPackedComponents)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetAddressMode(hTexRef not None : CUtexref, int dim, am not None : CUaddress_mode):
    cdef ccuda.CUaddress_mode cam = am.value
    err = ccuda.cuTexRefSetAddressMode(hTexRef._ptr[0], dim, cam)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetFilterMode(hTexRef not None : CUtexref, fm not None : CUfilter_mode):
    cdef ccuda.CUfilter_mode cfm = fm.value
    err = ccuda.cuTexRefSetFilterMode(hTexRef._ptr[0], cfm)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMipmapFilterMode(hTexRef not None : CUtexref, fm not None : CUfilter_mode):
    cdef ccuda.CUfilter_mode cfm = fm.value
    err = ccuda.cuTexRefSetMipmapFilterMode(hTexRef._ptr[0], cfm)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMipmapLevelBias(hTexRef not None : CUtexref, float bias):
    err = ccuda.cuTexRefSetMipmapLevelBias(hTexRef._ptr[0], bias)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMipmapLevelClamp(hTexRef not None : CUtexref, float minMipmapLevelClamp, float maxMipmapLevelClamp):
    err = ccuda.cuTexRefSetMipmapLevelClamp(hTexRef._ptr[0], minMipmapLevelClamp, maxMipmapLevelClamp)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMaxAnisotropy(hTexRef not None : CUtexref, unsigned int maxAniso):
    err = ccuda.cuTexRefSetMaxAnisotropy(hTexRef._ptr[0], maxAniso)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetBorderColor(hTexRef not None : CUtexref, float pBorderColor):
    err = ccuda.cuTexRefSetBorderColor(hTexRef._ptr[0], &pBorderColor)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetFlags(hTexRef not None : CUtexref, unsigned int Flags):
    err = ccuda.cuTexRefSetFlags(hTexRef._ptr[0], Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefGetAddress(hTexRef not None : CUtexref):
    cdef CUdeviceptr pdptr = CUdeviceptr()
    err = ccuda.cuTexRefGetAddress(pdptr._ptr, hTexRef._ptr[0])
    return (CUresult(err), pdptr)

@cython.embedsignature(True)
def cuTexRefGetArray(hTexRef not None : CUtexref):
    cdef CUarray phArray = CUarray()
    err = ccuda.cuTexRefGetArray(phArray._ptr, hTexRef._ptr[0])
    return (CUresult(err), phArray)

@cython.embedsignature(True)
def cuTexRefGetMipmappedArray(hTexRef not None : CUtexref):
    cdef CUmipmappedArray phMipmappedArray = CUmipmappedArray()
    err = ccuda.cuTexRefGetMipmappedArray(phMipmappedArray._ptr, hTexRef._ptr[0])
    return (CUresult(err), phMipmappedArray)

@cython.embedsignature(True)
def cuTexRefGetAddressMode(hTexRef not None : CUtexref, int dim):
    cdef ccuda.CUaddress_mode pam
    err = ccuda.cuTexRefGetAddressMode(&pam, hTexRef._ptr[0], dim)
    return (CUresult(err), CUaddress_mode(pam))

@cython.embedsignature(True)
def cuTexRefGetFilterMode(hTexRef not None : CUtexref):
    cdef ccuda.CUfilter_mode pfm
    err = ccuda.cuTexRefGetFilterMode(&pfm, hTexRef._ptr[0])
    return (CUresult(err), CUfilter_mode(pfm))

@cython.embedsignature(True)
def cuTexRefGetFormat(hTexRef not None : CUtexref):
    cdef ccuda.CUarray_format pFormat
    cdef int pNumChannels = 0
    err = ccuda.cuTexRefGetFormat(&pFormat, &pNumChannels, hTexRef._ptr[0])
    return (CUresult(err), CUarray_format(pFormat), pNumChannels)

@cython.embedsignature(True)
def cuTexRefGetMipmapFilterMode(hTexRef not None : CUtexref):
    cdef ccuda.CUfilter_mode pfm
    err = ccuda.cuTexRefGetMipmapFilterMode(&pfm, hTexRef._ptr[0])
    return (CUresult(err), CUfilter_mode(pfm))

@cython.embedsignature(True)
def cuTexRefGetMipmapLevelBias(hTexRef not None : CUtexref):
    cdef float pbias = 0
    err = ccuda.cuTexRefGetMipmapLevelBias(&pbias, hTexRef._ptr[0])
    return (CUresult(err), pbias)

@cython.embedsignature(True)
def cuTexRefGetMipmapLevelClamp(hTexRef not None : CUtexref):
    cdef float pminMipmapLevelClamp = 0
    cdef float pmaxMipmapLevelClamp = 0
    err = ccuda.cuTexRefGetMipmapLevelClamp(&pminMipmapLevelClamp, &pmaxMipmapLevelClamp, hTexRef._ptr[0])
    return (CUresult(err), pminMipmapLevelClamp, pmaxMipmapLevelClamp)

@cython.embedsignature(True)
def cuTexRefGetMaxAnisotropy(hTexRef not None : CUtexref):
    cdef int pmaxAniso = 0
    err = ccuda.cuTexRefGetMaxAnisotropy(&pmaxAniso, hTexRef._ptr[0])
    return (CUresult(err), pmaxAniso)

@cython.embedsignature(True)
def cuTexRefGetBorderColor(hTexRef not None : CUtexref):
    cdef float pBorderColor = 0
    err = ccuda.cuTexRefGetBorderColor(&pBorderColor, hTexRef._ptr[0])
    return (CUresult(err), pBorderColor)

@cython.embedsignature(True)
def cuTexRefGetFlags(hTexRef not None : CUtexref):
    cdef unsigned int pFlags = 0
    err = ccuda.cuTexRefGetFlags(&pFlags, hTexRef._ptr[0])
    return (CUresult(err), pFlags)

@cython.embedsignature(True)
def cuTexRefCreate():
    cdef CUtexref pTexRef = CUtexref()
    err = ccuda.cuTexRefCreate(pTexRef._ptr)
    return (CUresult(err), pTexRef)

@cython.embedsignature(True)
def cuTexRefDestroy(hTexRef not None : CUtexref):
    err = ccuda.cuTexRefDestroy(hTexRef._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuSurfRefSetArray(hSurfRef not None : CUsurfref, hArray not None : CUarray, unsigned int Flags):
    err = ccuda.cuSurfRefSetArray(hSurfRef._ptr[0], hArray._ptr[0], Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuSurfRefGetArray(hSurfRef not None : CUsurfref):
    cdef CUarray phArray = CUarray()
    err = ccuda.cuSurfRefGetArray(phArray._ptr, hSurfRef._ptr[0])
    return (CUresult(err), phArray)

@cython.embedsignature(True)
def cuTexObjectCreate(pResDesc : CUDA_RESOURCE_DESC, pTexDesc : CUDA_TEXTURE_DESC, pResViewDesc : CUDA_RESOURCE_VIEW_DESC):
    cdef CUtexObject pTexObject = CUtexObject()
    cdef ccuda.CUDA_RESOURCE_DESC* cpResDesc_ptr = pResDesc._ptr if pResDesc != None else NULL
    cdef ccuda.CUDA_TEXTURE_DESC* cpTexDesc_ptr = pTexDesc._ptr if pTexDesc != None else NULL
    cdef ccuda.CUDA_RESOURCE_VIEW_DESC* cpResViewDesc_ptr = pResViewDesc._ptr if pResViewDesc != None else NULL
    err = ccuda.cuTexObjectCreate(pTexObject._ptr, cpResDesc_ptr, cpTexDesc_ptr, cpResViewDesc_ptr)
    return (CUresult(err), pTexObject)

@cython.embedsignature(True)
def cuTexObjectDestroy(texObject not None : CUtexObject):
    err = ccuda.cuTexObjectDestroy(texObject._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexObjectGetResourceDesc(texObject not None : CUtexObject):
    cdef CUDA_RESOURCE_DESC pResDesc = CUDA_RESOURCE_DESC()
    err = ccuda.cuTexObjectGetResourceDesc(pResDesc._ptr, texObject._ptr[0])
    return (CUresult(err), pResDesc)

@cython.embedsignature(True)
def cuTexObjectGetTextureDesc(texObject not None : CUtexObject):
    cdef CUDA_TEXTURE_DESC pTexDesc = CUDA_TEXTURE_DESC()
    err = ccuda.cuTexObjectGetTextureDesc(pTexDesc._ptr, texObject._ptr[0])
    return (CUresult(err), pTexDesc)

@cython.embedsignature(True)
def cuTexObjectGetResourceViewDesc(texObject not None : CUtexObject):
    cdef CUDA_RESOURCE_VIEW_DESC pResViewDesc = CUDA_RESOURCE_VIEW_DESC()
    err = ccuda.cuTexObjectGetResourceViewDesc(pResViewDesc._ptr, texObject._ptr[0])
    return (CUresult(err), pResViewDesc)

@cython.embedsignature(True)
def cuSurfObjectCreate(pResDesc : CUDA_RESOURCE_DESC):
    cdef CUsurfObject pSurfObject = CUsurfObject()
    cdef ccuda.CUDA_RESOURCE_DESC* cpResDesc_ptr = pResDesc._ptr if pResDesc != None else NULL
    err = ccuda.cuSurfObjectCreate(pSurfObject._ptr, cpResDesc_ptr)
    return (CUresult(err), pSurfObject)

@cython.embedsignature(True)
def cuSurfObjectDestroy(surfObject not None : CUsurfObject):
    err = ccuda.cuSurfObjectDestroy(surfObject._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuSurfObjectGetResourceDesc(surfObject not None : CUsurfObject):
    cdef CUDA_RESOURCE_DESC pResDesc = CUDA_RESOURCE_DESC()
    err = ccuda.cuSurfObjectGetResourceDesc(pResDesc._ptr, surfObject._ptr[0])
    return (CUresult(err), pResDesc)

@cython.embedsignature(True)
def cuDeviceCanAccessPeer(dev not None : CUdevice, peerDev not None : CUdevice):
    cdef int canAccessPeer = 0
    err = ccuda.cuDeviceCanAccessPeer(&canAccessPeer, dev._ptr[0], peerDev._ptr[0])
    return (CUresult(err), canAccessPeer)

@cython.embedsignature(True)
def cuCtxEnablePeerAccess(peerContext not None : CUcontext, unsigned int Flags):
    err = ccuda.cuCtxEnablePeerAccess(peerContext._ptr[0], Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxDisablePeerAccess(peerContext not None : CUcontext):
    err = ccuda.cuCtxDisablePeerAccess(peerContext._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetP2PAttribute(attrib not None : CUdevice_P2PAttribute, srcDevice not None : CUdevice, dstDevice not None : CUdevice):
    cdef int value = 0
    cdef ccuda.CUdevice_P2PAttribute cattrib = attrib.value
    err = ccuda.cuDeviceGetP2PAttribute(&value, cattrib, srcDevice._ptr[0], dstDevice._ptr[0])
    return (CUresult(err), value)

@cython.embedsignature(True)
def cuGraphicsUnregisterResource(resource not None : CUgraphicsResource):
    err = ccuda.cuGraphicsUnregisterResource(resource._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphicsSubResourceGetMappedArray(resource not None : CUgraphicsResource, unsigned int arrayIndex, unsigned int mipLevel):
    cdef CUarray pArray = CUarray()
    err = ccuda.cuGraphicsSubResourceGetMappedArray(pArray._ptr, resource._ptr[0], arrayIndex, mipLevel)
    return (CUresult(err), pArray)

@cython.embedsignature(True)
def cuGraphicsResourceGetMappedMipmappedArray(resource not None : CUgraphicsResource):
    cdef CUmipmappedArray pMipmappedArray = CUmipmappedArray()
    err = ccuda.cuGraphicsResourceGetMappedMipmappedArray(pMipmappedArray._ptr, resource._ptr[0])
    return (CUresult(err), pMipmappedArray)

@cython.embedsignature(True)
def cuGraphicsResourceGetMappedPointer(resource not None : CUgraphicsResource):
    cdef CUdeviceptr pDevPtr = CUdeviceptr()
    cdef size_t pSize = 0
    err = ccuda.cuGraphicsResourceGetMappedPointer(pDevPtr._ptr, &pSize, resource._ptr[0])
    return (CUresult(err), pDevPtr, pSize)

@cython.embedsignature(True)
def cuGraphicsResourceSetMapFlags(resource not None : CUgraphicsResource, unsigned int flags):
    err = ccuda.cuGraphicsResourceSetMapFlags(resource._ptr[0], flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphicsMapResources(unsigned int count, resources : CUgraphicsResource, hStream not None : CUstream):
    cdef ccuda.CUgraphicsResource* cresources_ptr = resources._ptr if resources != None else NULL
    err = ccuda.cuGraphicsMapResources(count, cresources_ptr, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphicsUnmapResources(unsigned int count, resources : CUgraphicsResource, hStream not None : CUstream):
    cdef ccuda.CUgraphicsResource* cresources_ptr = resources._ptr if resources != None else NULL
    err = ccuda.cuGraphicsUnmapResources(count, cresources_ptr, hStream._ptr[0])
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGetProcAddress(char* symbol, int cudaVersion, flags not None : cuuint64_t):
    cdef void_ptr pfn = 0
    err = ccuda.cuGetProcAddress(symbol, <void**>&pfn, cudaVersion, flags._ptr[0])
    return (CUresult(err), pfn)

@cython.embedsignature(True)
def cuGetExportTable(pExportTableId : CUuuid):
    cdef void_ptr ppExportTable = 0
    cdef ccuda.CUuuid* cpExportTableId_ptr = pExportTableId._ptr if pExportTableId != None else NULL
    err = ccuda.cuGetExportTable(<const void**>&ppExportTable, cpExportTableId_ptr)
    return (CUresult(err), ppExportTable)

@cython.embedsignature(True)
def cuFlushGPUDirectRDMAWrites(target not None : CUflushGPUDirectRDMAWritesTarget, scope not None : CUflushGPUDirectRDMAWritesScope):
    cdef ccuda.CUflushGPUDirectRDMAWritesTarget ctarget = target.value
    cdef ccuda.CUflushGPUDirectRDMAWritesScope cscope = scope.value
    err = ccuda.cuFlushGPUDirectRDMAWrites(ctarget, cscope)
    return (CUresult(err),)

@cython.embedsignature(True)
def sizeof(objType):
    if objType == CUuuid_st:
        return sizeof(ccuda.CUuuid_st)
    if objType == CUipcEventHandle_st:
        return sizeof(ccuda.CUipcEventHandle_st)
    if objType == CUipcMemHandle_st:
        return sizeof(ccuda.CUipcMemHandle_st)
    if objType == CUstreamMemOpWaitValueParams_st:
        return sizeof(ccuda.CUstreamMemOpWaitValueParams_st)
    if objType == CUstreamMemOpWriteValueParams_st:
        return sizeof(ccuda.CUstreamMemOpWriteValueParams_st)
    if objType == CUstreamMemOpFlushRemoteWritesParams_st:
        return sizeof(ccuda.CUstreamMemOpFlushRemoteWritesParams_st)
    if objType == CUstreamBatchMemOpParams_union:
        return sizeof(ccuda.CUstreamBatchMemOpParams_union)
    if objType == CUdevprop_st:
        return sizeof(ccuda.CUdevprop_st)
    if objType == CUaccessPolicyWindow_st:
        return sizeof(ccuda.CUaccessPolicyWindow_st)
    if objType == CUDA_KERNEL_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_KERNEL_NODE_PARAMS_st)
    if objType == CUDA_MEMSET_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_MEMSET_NODE_PARAMS_st)
    if objType == CUDA_HOST_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_HOST_NODE_PARAMS_st)
    if objType == CUkernelNodeAttrValue_union:
        return sizeof(ccuda.CUkernelNodeAttrValue_union)
    if objType == CUstreamAttrValue_union:
        return sizeof(ccuda.CUstreamAttrValue_union)
    if objType == CUexecAffinitySmCount_st:
        return sizeof(ccuda.CUexecAffinitySmCount_st)
    if objType == CUexecAffinityParam_st:
        return sizeof(ccuda.CUexecAffinityParam_st)
    if objType == CUDA_MEMCPY2D_st:
        return sizeof(ccuda.CUDA_MEMCPY2D_st)
    if objType == CUDA_MEMCPY3D_st:
        return sizeof(ccuda.CUDA_MEMCPY3D_st)
    if objType == CUDA_MEMCPY3D_PEER_st:
        return sizeof(ccuda.CUDA_MEMCPY3D_PEER_st)
    if objType == CUDA_ARRAY_DESCRIPTOR_st:
        return sizeof(ccuda.CUDA_ARRAY_DESCRIPTOR_st)
    if objType == CUDA_ARRAY3D_DESCRIPTOR_st:
        return sizeof(ccuda.CUDA_ARRAY3D_DESCRIPTOR_st)
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES_st:
        return sizeof(ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st)
    if objType == CUDA_RESOURCE_DESC_st:
        return sizeof(ccuda.CUDA_RESOURCE_DESC_st)
    if objType == CUDA_TEXTURE_DESC_st:
        return sizeof(ccuda.CUDA_TEXTURE_DESC_st)
    if objType == CUDA_RESOURCE_VIEW_DESC_st:
        return sizeof(ccuda.CUDA_RESOURCE_VIEW_DESC_st)
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st:
        return sizeof(ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
    if objType == CUDA_LAUNCH_PARAMS_st:
        return sizeof(ccuda.CUDA_LAUNCH_PARAMS_st)
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st)
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st)
    if objType == CUarrayMapInfo_st:
        return sizeof(ccuda.CUarrayMapInfo_st)
    if objType == CUmemLocation_st:
        return sizeof(ccuda.CUmemLocation_st)
    if objType == CUmemAllocationProp_st:
        return sizeof(ccuda.CUmemAllocationProp_st)
    if objType == CUmemAccessDesc_st:
        return sizeof(ccuda.CUmemAccessDesc_st)
    if objType == CUmemPoolProps_st:
        return sizeof(ccuda.CUmemPoolProps_st)
    if objType == CUmemPoolPtrExportData_st:
        return sizeof(ccuda.CUmemPoolPtrExportData_st)
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_MEM_ALLOC_NODE_PARAMS_st)
    if objType == CUcontext:
        return sizeof(ccuda.CUcontext)
    if objType == CUmodule:
        return sizeof(ccuda.CUmodule)
    if objType == CUfunction:
        return sizeof(ccuda.CUfunction)
    if objType == CUarray:
        return sizeof(ccuda.CUarray)
    if objType == CUmipmappedArray:
        return sizeof(ccuda.CUmipmappedArray)
    if objType == CUtexref:
        return sizeof(ccuda.CUtexref)
    if objType == CUsurfref:
        return sizeof(ccuda.CUsurfref)
    if objType == CUevent:
        return sizeof(ccuda.CUevent)
    if objType == CUstream:
        return sizeof(ccuda.CUstream)
    if objType == CUgraphicsResource:
        return sizeof(ccuda.CUgraphicsResource)
    if objType == CUexternalMemory:
        return sizeof(ccuda.CUexternalMemory)
    if objType == CUexternalSemaphore:
        return sizeof(ccuda.CUexternalSemaphore)
    if objType == CUgraph:
        return sizeof(ccuda.CUgraph)
    if objType == CUgraphNode:
        return sizeof(ccuda.CUgraphNode)
    if objType == CUgraphExec:
        return sizeof(ccuda.CUgraphExec)
    if objType == CUmemoryPool:
        return sizeof(ccuda.CUmemoryPool)
    if objType == CUuserObject:
        return sizeof(ccuda.CUuserObject)
    if objType == CUlinkState:
        return sizeof(ccuda.CUlinkState)
    if objType == CUhostFn:
        return sizeof(ccuda.CUhostFn)
    if objType == CUstreamCallback:
        return sizeof(ccuda.CUstreamCallback)
    if objType == CUoccupancyB2DSize:
        return sizeof(ccuda.CUoccupancyB2DSize)
    if objType == CUuuid:
        return sizeof(ccuda.CUuuid)
    if objType == CUipcEventHandle_v1:
        return sizeof(ccuda.CUipcEventHandle_v1)
    if objType == CUipcEventHandle:
        return sizeof(ccuda.CUipcEventHandle)
    if objType == CUipcMemHandle_v1:
        return sizeof(ccuda.CUipcMemHandle_v1)
    if objType == CUipcMemHandle:
        return sizeof(ccuda.CUipcMemHandle)
    if objType == CUstreamBatchMemOpParams_v1:
        return sizeof(ccuda.CUstreamBatchMemOpParams_v1)
    if objType == CUstreamBatchMemOpParams:
        return sizeof(ccuda.CUstreamBatchMemOpParams)
    if objType == CUdevprop_v1:
        return sizeof(ccuda.CUdevprop_v1)
    if objType == CUdevprop:
        return sizeof(ccuda.CUdevprop)
    if objType == CUaccessPolicyWindow_v1:
        return sizeof(ccuda.CUaccessPolicyWindow_v1)
    if objType == CUaccessPolicyWindow:
        return sizeof(ccuda.CUaccessPolicyWindow)
    if objType == CUDA_KERNEL_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_KERNEL_NODE_PARAMS_v1)
    if objType == CUDA_KERNEL_NODE_PARAMS:
        return sizeof(ccuda.CUDA_KERNEL_NODE_PARAMS)
    if objType == CUDA_MEMSET_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_MEMSET_NODE_PARAMS_v1)
    if objType == CUDA_MEMSET_NODE_PARAMS:
        return sizeof(ccuda.CUDA_MEMSET_NODE_PARAMS)
    if objType == CUDA_HOST_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_HOST_NODE_PARAMS_v1)
    if objType == CUDA_HOST_NODE_PARAMS:
        return sizeof(ccuda.CUDA_HOST_NODE_PARAMS)
    if objType == CUkernelNodeAttrValue_v1:
        return sizeof(ccuda.CUkernelNodeAttrValue_v1)
    if objType == CUkernelNodeAttrValue:
        return sizeof(ccuda.CUkernelNodeAttrValue)
    if objType == CUstreamAttrValue_v1:
        return sizeof(ccuda.CUstreamAttrValue_v1)
    if objType == CUstreamAttrValue:
        return sizeof(ccuda.CUstreamAttrValue)
    if objType == CUexecAffinitySmCount_v1:
        return sizeof(ccuda.CUexecAffinitySmCount_v1)
    if objType == CUexecAffinitySmCount:
        return sizeof(ccuda.CUexecAffinitySmCount)
    if objType == CUexecAffinityParam_v1:
        return sizeof(ccuda.CUexecAffinityParam_v1)
    if objType == CUexecAffinityParam:
        return sizeof(ccuda.CUexecAffinityParam)
    if objType == CUDA_MEMCPY2D_v2:
        return sizeof(ccuda.CUDA_MEMCPY2D_v2)
    if objType == CUDA_MEMCPY2D:
        return sizeof(ccuda.CUDA_MEMCPY2D)
    if objType == CUDA_MEMCPY3D_v2:
        return sizeof(ccuda.CUDA_MEMCPY3D_v2)
    if objType == CUDA_MEMCPY3D:
        return sizeof(ccuda.CUDA_MEMCPY3D)
    if objType == CUDA_MEMCPY3D_PEER_v1:
        return sizeof(ccuda.CUDA_MEMCPY3D_PEER_v1)
    if objType == CUDA_MEMCPY3D_PEER:
        return sizeof(ccuda.CUDA_MEMCPY3D_PEER)
    if objType == CUDA_ARRAY_DESCRIPTOR_v2:
        return sizeof(ccuda.CUDA_ARRAY_DESCRIPTOR_v2)
    if objType == CUDA_ARRAY_DESCRIPTOR:
        return sizeof(ccuda.CUDA_ARRAY_DESCRIPTOR)
    if objType == CUDA_ARRAY3D_DESCRIPTOR_v2:
        return sizeof(ccuda.CUDA_ARRAY3D_DESCRIPTOR_v2)
    if objType == CUDA_ARRAY3D_DESCRIPTOR:
        return sizeof(ccuda.CUDA_ARRAY3D_DESCRIPTOR)
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES_v1:
        return sizeof(ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_v1)
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES:
        return sizeof(ccuda.CUDA_ARRAY_SPARSE_PROPERTIES)
    if objType == CUDA_RESOURCE_DESC_v1:
        return sizeof(ccuda.CUDA_RESOURCE_DESC_v1)
    if objType == CUDA_RESOURCE_DESC:
        return sizeof(ccuda.CUDA_RESOURCE_DESC)
    if objType == CUDA_TEXTURE_DESC_v1:
        return sizeof(ccuda.CUDA_TEXTURE_DESC_v1)
    if objType == CUDA_TEXTURE_DESC:
        return sizeof(ccuda.CUDA_TEXTURE_DESC)
    if objType == CUDA_RESOURCE_VIEW_DESC_v1:
        return sizeof(ccuda.CUDA_RESOURCE_VIEW_DESC_v1)
    if objType == CUDA_RESOURCE_VIEW_DESC:
        return sizeof(ccuda.CUDA_RESOURCE_VIEW_DESC)
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1:
        return sizeof(ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1)
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS:
        return sizeof(ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS)
    if objType == CUDA_LAUNCH_PARAMS_v1:
        return sizeof(ccuda.CUDA_LAUNCH_PARAMS_v1)
    if objType == CUDA_LAUNCH_PARAMS:
        return sizeof(ccuda.CUDA_LAUNCH_PARAMS)
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1)
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC)
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1)
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC)
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1)
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC)
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1)
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1)
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1)
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1)
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS:
        return sizeof(ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS)
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1)
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS:
        return sizeof(ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS)
    if objType == CUarrayMapInfo_v1:
        return sizeof(ccuda.CUarrayMapInfo_v1)
    if objType == CUarrayMapInfo:
        return sizeof(ccuda.CUarrayMapInfo)
    if objType == CUmemLocation_v1:
        return sizeof(ccuda.CUmemLocation_v1)
    if objType == CUmemLocation:
        return sizeof(ccuda.CUmemLocation)
    if objType == CUmemAllocationProp_v1:
        return sizeof(ccuda.CUmemAllocationProp_v1)
    if objType == CUmemAllocationProp:
        return sizeof(ccuda.CUmemAllocationProp)
    if objType == CUmemAccessDesc_v1:
        return sizeof(ccuda.CUmemAccessDesc_v1)
    if objType == CUmemAccessDesc:
        return sizeof(ccuda.CUmemAccessDesc)
    if objType == CUmemPoolProps_v1:
        return sizeof(ccuda.CUmemPoolProps_v1)
    if objType == CUmemPoolProps:
        return sizeof(ccuda.CUmemPoolProps)
    if objType == CUmemPoolPtrExportData_v1:
        return sizeof(ccuda.CUmemPoolPtrExportData_v1)
    if objType == CUmemPoolPtrExportData:
        return sizeof(ccuda.CUmemPoolPtrExportData)
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS:
        return sizeof(ccuda.CUDA_MEM_ALLOC_NODE_PARAMS)
    if objType == cuuint32_t:
        return sizeof(ccuda.cuuint32_t)
    if objType == cuuint64_t:
        return sizeof(ccuda.cuuint64_t)
    if objType == CUdeviceptr_v2:
        return sizeof(ccuda.CUdeviceptr_v2)
    if objType == CUdeviceptr:
        return sizeof(ccuda.CUdeviceptr)
    if objType == CUdevice_v1:
        return sizeof(ccuda.CUdevice_v1)
    if objType == CUdevice:
        return sizeof(ccuda.CUdevice)
    if objType == CUtexObject_v1:
        return sizeof(ccuda.CUtexObject_v1)
    if objType == CUtexObject:
        return sizeof(ccuda.CUtexObject)
    if objType == CUsurfObject_v1:
        return sizeof(ccuda.CUsurfObject_v1)
    if objType == CUsurfObject:
        return sizeof(ccuda.CUsurfObject)
    if objType == CUmemGenericAllocationHandle_v1:
        return sizeof(ccuda.CUmemGenericAllocationHandle_v1)
    if objType == CUmemGenericAllocationHandle:
        return sizeof(ccuda.CUmemGenericAllocationHandle)
    raise TypeError("Unknown type: " + str(objType))
